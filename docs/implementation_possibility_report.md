# Implementation Possibility Report: Stepback & History Jump

## 1. 概要
本レポートは、現在のRetro Core Tracerの実装状況に基づき、当初の設計思想であった「Stepback（1命令戻る）」および「History Jump（任意の過去の状態へ戻る）」機能の実装可能性を調査した結果である。

**結論:**
**技術的に実装可能である。**
Core LayerおよびDebugger Layerの設計は、当初からこの機能を想定して「不変Snapshot」と「状態分離」の原則に基づいて構築されており、大きなアーキテクチャ変更なしに実現できる。ただし、メモリ（RAM）の状態管理において、いくつかの技術的課題を解決する必要がある。

## 2. 現状のアーキテクチャとの適合性

### 2.1. 適合する点 (Pros)
1.  **不変Snapshotの存在:**
    *   `AbstractCpu.step()` は実行結果として `Snapshot` オブジェクトを返す。この `Snapshot` には、実行直後の `CpuState`（レジスタ全状態）が不変オブジェクトとして記録されている。
    *   これは「過去の状態」をそのまま保存していることに他ならず、History機能の根幹となるデータ構造は既に完成している。
2.  **Stateの分離:**
    *   `CpuState` はデータクラスとしてCPUロジックから分離されており、`cpu._state = snapshot.state` のように過去の状態を代入するだけで、CPUのレジスタ状態を瞬時に復元できる設計になっている。
3.  **Debuggerの責務:**
    *   `Debugger` クラスは既に実行制御の中枢であり、履歴管理を行う自然な場所である。

### 2.2. 課題となる点 (Cons)
1.  **メモリ（RAM）状態の復元:**
    *   現在の `Snapshot` は、CPUレジスタの状態は完全なコピーを持っているが、**メモリの状態（RAMの中身）は保持していない**。
    *   `Snapshot` に記録されているのは「そのサイクルで発生したバスアクセス (`bus_activity`)」のみである。
    *   単純に `cpu._state` を戻すだけでは、RAMの内容が未来の状態のままになってしまい、不整合が発生する。
2.  **外部デバイス（I/O）の状態:**
    *   RAMと同様、I/Oデバイスの状態もSnapshotには含まれていない。単純なRAMベースのI/Oデバイスならメモリと同様に扱えるが、副作用を持つデバイス（例：シリアル通信のバッファ）の状態復元は困難である。

## 3. 実装戦略案

### 3.1. 戦略A: 差分記録方式 (Reverse Log) - 推奨
Stepback時に、その命令で行われた「メモリ書き込み」を打ち消す逆操作を行う方式。

*   **仕組み:**
    1.  `Snapshot.bus_activity` を走査する。
    2.  `WRITE` アクセスが見つかった場合、**「書き込まれる前の値」** が必要になる。
*   **必要な変更:**
    *   `Bus` クラスの `write` メソッドを変更し、書き込み前の値を読み取ってログ (`BusAccess`) に含めるようにする（例: `old_data` フィールドの追加）。
    *   または、`Snapshot` 生成時に、その命令によって変更されたメモリアドレスの「変更前の値」を別途記録する。

### 3.2. 戦略B: 完全ステートセーブ方式 (Full State Save)
一定間隔（例: 1000サイクル毎）でRAM全体のコピーを保存する。

*   **仕組み:**
    *   戻りたい地点に最も近い「キーフレーム」まで戻り、そこから目的のサイクルまで順方向実行（Replay）する。
*   **評価:**
    *   レトロPCのRAM（64KB程度）なら毎サイクル全コピーしても現代のPCなら動作するかもしれないが、メモリ効率が悪い。戦略Aとの併用が現実的。

## 4. 具体的な実装ステップ (Roadmap)

1.  **Bus機能の拡張:**
    *   `Bus.write` 実行時に、書き換えられる前の値を `read` して取得し、`BusAccess` ログに `previous_data` として記録する機能を追加する。
2.  **Debuggerの履歴管理機能強化:**
    *   `Debugger` クラスに `_history: List[Snapshot]` を持たせる（現在は `_last_snapshot` のみ）。
    *   リングバッファ等で履歴サイズを制限する設定も検討。
3.  **Stepbackメソッドの実装:**
    *   `Debugger.step_back()` メソッドを作成。
    *   履歴から1つ前のSnapshotを取り出す。
    *   Snapshot内の `bus_activity` を逆順にスキャンし、`WRITE` 操作があれば `previous_data` の値でメモリを書き戻す。
    *   最後に `cpu._state` をSnapshot（の1つ前の状態）で上書きする。
4.  **UIへの統合:**
    *   ツールバーに「Back」ボタンを追加。
    *   スライダーバーで履歴位置（タイムライン）を操作できるUIを追加。

## 5. 結論
RAMの「書き込み前の値」を記録する小さな拡張を行うことで、現在のアーキテクチャを活かしたまま、高度な Stepback / History Jump 機能を実現できる。これは「教育的透明性」というプロジェクトの目標に対しても、試行錯誤を容易にする強力な機能となるため、実装を強く推奨する。
