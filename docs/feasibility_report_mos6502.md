# Feasibility Report: MOS 6502 Integration into Retro Core Tracer

## 1. 概要
本レポートは、既存の「Retro Core Tracer (RCT)」プロジェクトに対し、第3のCPUアーキテクチャとして **MOS 6502** を追加実装することの技術的実現可能性を評価したものである。

**結論: 実装は十分に可能であり、既存のRCTアーキテクチャを破壊することなく、高い整合性を持って統合できる。**

## 2. アーキテクチャ適合性分析

### 2.1. Transport Layer (Bus & Memory)
*   **仕様:** MOS 6502は16ビットアドレスバス、8ビットデータバスを持つ。
*   **RCT適合:** RCTの `Bus` クラスは既にこの仕様を標準としており、完全に適合する。
*   **I/O:** 6502はメモリマップドI/Oを採用している。これはRCTの `MC6800` 実装と同じアプローチ（`has_io_port = False`）で対応可能であり、特別な拡張を必要としない。
*   **エンディアン:** 6502はリトルエンディアンである。RCTの基盤（Z80由来）と親和性が高く、`MC6800` のようなビッグエンディアン変換層も不要であるため、実装はシンプルになる。

### 2.2. Core Layer (CPU Abstraction)
*   **AbstractCpu:** 6502の動作モデル（Fetch-Decode-Executeサイクル）は `AbstractCpu` の想定範囲内である。
*   **レジスタ:** `A`, `X`, `Y` (8bit), `PC` (16bit), `S` (8bit), `P` (8bit Status) という構成は、`CpuState` を継承した `Mos6502CpuState` を定義することで問題なく表現できる。
*   **ステータスフラグ:** `NV-BDIZC` のフラグ構成は標準的であり、既存のフラグビューで表示可能である。

## 3. 実装上の重要ポイントと解決策

### 3.1. スタックポインタ (SP) の扱い
*   **課題:** 6502のSPは8ビットレジスタであり、ハードウェア的に `0x0100 - 0x01FF` の固定ページにマッピングされる。一方、RCTの `StackView` は `state.sp` の値をそのまま絶対アドレスとして解釈して表示する。単純に8ビット値を返すと、ゼロページ（`0x00xx`）がスタックとして表示されてしまう。
*   **解決策:**
    *   内部ロジック（`Mos6502Cpu`）ではSPを8ビット（0x00-0xFF）として管理する。
    *   外部公開APIである `get_state()` メソッドをオーバーライドし、UIやデバッガに `CpuState` を渡す際、`sp` フィールドを `0x0100 | sp` に補正して返す。
    *   これにより、UI側は変更することなく正しいスタック領域を表示できる。

### 3.2. BCD (Binary Coded Decimal) モード
*   **課題:** 6502は `D` (Decimal) フラグがセットされている場合、`ADC`, `SBC` 命令がBCD演算として動作する。
*   **解決策:**
    *   これはアーキテクチャ固有の論理演算ロジック (`arch/mos6502/instructions/alu.py`) 内に閉じて実装可能である。
    *   RCTのコアフレームワーク自体への変更は不要。

### 3.3. 命令サイクルとページ境界ペナルティ
*   **課題:** 条件分岐やインデックス修飾アドレッシングにおいて、ページ境界（256バイト境界）を跨ぐアクセスが発生した場合、実行サイクルが+1される仕様がある。
*   **解決策:**
    *   命令実行ロジック内でページ境界判定を行い、`Operation` オブジェクトの `cycle_count` を動的に加算することで正確にシミュレートできる。

### 3.4. JMPバグとラップアラウンド
*   **課題:** `JMP ($xxFF)` のバグや、ゼロページアドレッシングのラップアラウンドなど、6502特有の挙動がある。
*   **解決策:**
    *   これらは「教育的透明性」の観点から、**実機の挙動（バグ含む）を正確に再現する**方針とする。これも命令実装内部の話であり、アーキテクチャへの影響はない。

## 4. UI / Debugger への影響
*   **RegisterView:** `get_register_layout()` で6502用のレイアウト（Accumulator, Index Registers, Pointers）を定義するだけで対応可能。
*   **Disassembler:** 6502固有の逆アセンブラ (`arch/mos6502/disassembler.py`) を実装し、`AbstractCpu.disassemble` から委譲する標準パターンで対応可能。

## 5. 結論
MOS 6502 のサポートは、RCTプロジェクトにとってリスクが低く、かつ「マルチアーキテクチャ対応基盤」としての汎用性を証明する良いマイルストーンとなる。

**推奨:** 実装を進めるべきである。
次のステップとして、`src/retro_core_tracer/arch/mos6502/` ディレクトリの作成と、マニフェストの定義から開始することを提案する。
