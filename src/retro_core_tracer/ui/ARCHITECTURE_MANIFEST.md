# ARCHITECTURE MANIFEST - Retro Core Tracer (UI Layer)

---
## Part 1: このマニフェストの取扱説明書 (Guide)

### 1. 目的 (Purpose): なぜこの憲章が存在するのか

このドキュメントは、プロジェクト「Retro Core Tracer」の特定モジュール「UI Layer」の「北極星」です。開発者とAIが共有する高レベルな目標と、決して譲れない技術的・哲学的制約を定義します。その目的は、場当たり的な実装を防ぎ、モジュールが長期にわたって技術的負債を抱えることなく、クリーンなアーキテクチャを維持し続けることにあります。

これにより、AIは単なるコード生成ツールを超え、アーキテクチャ全体と一貫した、より洞察に富んだ提案が可能な、真の協調開発パートナーとして機能します。

### 2. 憲章の書き方 (Guidelines)

*   **原則1: 具体的に記述する。**
    *   良い例: 「ステップ実行ボタンを押してから画面が更新されるまでの遅延は、50ms以内とする」のように、検証可能な目標を設定します。

*   **原則2: 「なぜ」に焦点を当てる。**
    *   ルールだけではなく、その背景にあるトレードオフの判断を明記します。これが憲章の形骸化を防ぎ、将来の変更を助けます。

*   **原則3: 「禁止」ではなく「判断の背景」を記述する。**
    *   「禁止事項」や「守るべきルール」といった思考停止を招く言葉を避け、「我々はこういう判断をした」といった形で、判断に至った文脈や背景そのものを記述します。

### 3. リスクと対策 (Risks and Mitigations)

*   **リスク:** ドキュメントが陳腐化し、現実のコードと乖離する。
    *   **対策:** アーキテクチャに影響を与えるコード変更は、必ずこのマニフェストの更新とセットでレビューします。

---
## Part 2: マニフェスト本体 (Content)

### 1. 核となる原則 (Core Principles)

- **原則: UIは特定のCPUアーキテクチャの実装詳細を知ってはならない。**
  - **理由:** マルチアーキテクチャ対応を容易にし、CPUの追加時にUIコードの修正を不要にするため。UIは `AbstractCpu` が提供するメタデータ（レイアウト、レジスタマップ、フラグ状態）のみに基づいて描画を行う。

- **原則: UIコンポーネントは、統一された初期化・更新インターフェースを持つ。**
  - **理由:** `MainWindow` が各ビューを一貫した方法で管理（Dependency Injectionおよび描画更新）できるようにし、結合度を下げるため。具体的には `set_context` (または `set_cpu`/`set_bus`) と `update_view` パターンを採用する。

### 2. 主要なアーキテクチャ決定の記録 (Key Architectural Decisions)

- **Date:** 2026-02-08
- **Core Principle:** UIは特定のCPUアーキテクチャの実装詳細を知ってはならない。
- **Decision:** データ駆動型UIへのリファクタリング。
- **Rationale:** MC6800対応に際し、Z80固有の記述がUIに散在していた課題を解決するため。

- **Date:** 2026-02-10
- **Core Principle:** UIコンポーネントは、統一された初期化・更新インターフェースを持つ。
- **Decision:** 全てのビュー（CodeView, HexView, StackView等）に対し、コンストラクタによる依存性注入ではなく、`set_cpu` / `set_bus` メソッドによる遅延初期化と、引数なしの `update_view` メソッドによる再描画を強制する。
- **Rationale:** 設定ファイル読み込み時に動的にシステム構成が変わるため、ビューのインスタンス再生成を行わずに依存オブジェクト（CPU/Bus）を差し替え可能にする必要がある。

- **Date:** 2026-02-10
- **Core Principle:** ユーザビリティの向上。
- **Decision:** 実行制御に「Reset」機能を追加。
- **Rationale:** 開発サイクル（コード修正 -> ロード -> 実行 -> リセット -> 再実行）をスムーズにするため。

### 3. モジュール構成 (Module Structure)

- **`app.py`**: アプリケーションのエントリーポイント。
- **`main_window.py`**: メインウィンドウのレイアウトと状態管理。
- **`register_view.py`**: 汎用的なレジスタ表示（動的生成）。
- **`flag_view.py`**: 汎用的なフラグ表示（動的生成）。
- **`code_view.py`**: 汎用的な逆アセンブル表示。
- **`hex_view.py`**: メモリダンプ表示。
- **`stack_view.py`**: スタック領域表示。
- **`breakpoint_view.py`**: ブレークポイント管理（多角的UI）。

### 4. コンポーネント設計仕様 (Component Design Specifications)

#### 4.1. MainWindow
- **責務:**
    - アプリケーション全体のライフサイクル管理。
    - システム構成（Config, CPU, Bus）のロードと構築。
    - 各子ビューへの依存性の注入 (`set_cpu`, `set_bus`)。
    - 実行ループ（Run/Step/Reset）の制御。

#### 4.4. RegisterView (レジスタビュー)
- **責務:** CPUアーキテクチャに依存しない汎用的なレジスタ値を表示する。
- **提供するAPI:**
    - `set_cpu(cpu: AbstractCpu)`: レイアウトを構築する。
    - `update_registers()`: 値を更新する。

#### 4.5. FlagView (フラグビュー)
- **責務:** CPUアーキテクチャに依存しない汎用的なフラグ状態を表示する。
- **提供するAPI:**
    - `set_cpu(cpu: AbstractCpu)`: ラベルを構築する。
    - `update_flags()`: 状態を更新する。

#### 4.6. HexView / StackView
- **責務:** バス上のメモリデータを可視化する。
- **提供するAPI:**
    - `set_bus(bus: Bus)` / `set_cpu(cpu: AbstractCpu, bus: Bus)`
    - `update_view()`: 現在の状態に基づいて再描画する。

#### 4.8. CodeView (コードビュー)
- **責務:** メモリ上の機械語を逆アセンブルして表示し、現在のPCをハイライトする。
- **API:**
    - `set_cpu(cpu: AbstractCpu)`
    - `set_symbol_map(map: SymbolMap)`
    - `update_code(pc: int)`: 指定PCを中心に表示を更新。