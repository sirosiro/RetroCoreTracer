# ARCHITECTURE MANIFEST - Retro Core Tracer (UI Layer)

---
## Part 1: このマニフェストの取扱説明書 (Guide)

### 1. 目的 (Purpose): なぜこの憲章が存在するのか

このドキュメントは、プロジェクト「Retro Core Tracer」の特定モジュール「UI Layer」の「北極星」です。開発者とAIが共有する高レベルな目標と、決して譲れない技術的・哲学的制約を定義します。その目的は、場当たり的な実装を防ぎ、モジュールが長期にわたって技術的負債を抱えることなく、クリーンなアーキテクチャを維持し続けることにあります。

これにより、AIは単なるコード生成ツールを超え、アーキテクチャ全体と一貫した、より洞察に富んだ提案が可能な、真の協調開発パートナーとして機能します。

### 2. 憲章の書き方 (Guidelines)

*   **原則1: 具体的に記述する。**
    *   良い例: 「ステップ実行ボタンを押してから画面が更新されるまでの遅延は、50ms以内とする」のように、検証可能な目標を設定します。

*   **原則2: 「なぜ」に焦点を当てる。**
    *   ルールだけではなく、その背景にあるトレードオフの判断を明記します。これが憲章の形骸化を防ぎ、将来の変更を助けます。

*   **原則3: 「禁止」ではなく「判断の背景」を記述する。**
    *   「禁止事項」や「守るべきルール」といった思考停止を招く言葉を避け、「我々はこういう判断をした」といった形で、判断に至った文脈や背景そのものを記述します。

### 3. リスクと対策 (Risks and Mitigations)

*   **リスク:** ドキュメントが陳腐化し、現実のコードと乖離する。
    *   **対策:** アーキテクチャに影響を与えるコード変更は、必ずこのマニフェストの更新とセットでレビューします。

---
## Part 2: マニフェスト本体 (Content)

### 1. 核となる原則 (Core Principles)

- **原則: UIは特定のCPUアーキテクチャの実装詳細を知ってはならない。**
  - **理由:** マルチアーキテクチャ対応を容易にし、CPUの追加時にUIコードの修正を不要にするため。UIは `AbstractCpu` が提供するメタデータ（レイアウト、レジスタマップ、フラグ状態）のみに基づいて描画を行う。

- **原則: UIは、SnapshotオブジェクトまたはCPUのメタデータ取得APIのみを情報源とする。**
  - **理由:** コアロジックとの疎結合を維持し、将来的な "Time Travel Debugging" への対応を容易にするため。

### 2. 主要なアーキテクチャ決定の記録 (Key Architectural Decisions)

- **Date:** 2026-02-08
- **Core Principle:** UIは特定のCPUアーキテクチャの実装詳細を知ってはならない。
- **Decision:** データ駆動型UIへのリファクタリング。
- **Rationale:** MC6800対応に際し、Z80固有の記述がUIに散在していた課題を解決するため。CPUから提供される `RegisterLayoutInfo` に基づいてUIを動的に構築する仕組みを導入した。

- **Date:** 2026-02-08
- **Core Principle:** デバッグ作業のリズムを優先するUX。
- **Decision:** ブレークポイント削除時のデフォルトボタンを [Yes] に設定。
- **Rationale:** 開発者が頻繁に行う「ブレークポイントの試行錯誤」において、削除確認が過度なノイズにならないよう、キーボード操作（Enter）で即座に承認できる構成とした。

### 3. モジュール構成 (Module Structure)

- **`app.py`**: アプリケーションのエントリーポイント。
- **`main_window.py`**: メインウィンドウのレイアウトと状態管理。
- **`register_view.py`**: 汎用的なレジスタ表示（動的生成）。
- **`flag_view.py`**: 汎用的なフラグ表示（動的生成）。
- **`code_view.py`**: 汎用的な逆アセンブル表示。
- **`breakpoint_view.py`**: ブレークポイント管理（多角的UI）。

### 4. コンポーネント設計仕様 (Component Design Specifications)

#### 4.4. RegisterView (レジスタビュー)
- **責務:** CPUアーキテクチャに依存しない汎用的なレジスタ値を表示する。
- **提供するAPI:**
    - `set_cpu(cpu: AbstractCpu)`: `get_register_layout()` に基づき QGroupBox と QFormLayout を動的に構築する。
    - `update_registers()`: `get_register_map()` から値を取得し、対応するラベルを更新する。

#### 4.5. FlagView (フラグビュー)
- **責務:** CPUアーキテクチャに依存しない汎用的なフラグ状態を表示する。
- **提供するAPI:**
    - `set_cpu(cpu: AbstractCpu)`: `get_flag_state()` のキーに基づいてラベルを動的に生成する。
    - `update_flags()`: `get_flag_state()` の値（bool）に基づいて "0/1" 表示を更新する。

#### 4.7. BreakpointView (ブレークポイント管理ビュー)
- **責務:** ブレークポイントの多角的な管理（追加・削除・一覧）を提供する。
- **提供するUI機能:**
    - **動的追加:** 数値、16進数、シンボル名による指定をサポート。
    - **多角的な削除操作:** 削除ボタン、コンテキストメニュー（右クリック）、キーボード（Delete/Backspace）に対応。
    - **削除確認:** デフォルトを [Yes] に設定したモーダルダイアログ。
- **信号 (Signals):**
    - `breakpoint_added(BreakpointCondition)`
    - `breakpoint_removed(BreakpointCondition)`

#### 4.8. CodeView (コードビュー)
- **責務:** メモリ上の機械語を逆アセンブルして表示し、現在のPCをハイライトする。
- **主要なアルゴリズム:**
    - **抽象逆アセンブル:** 内部で Z80 モジュールを呼ばず、`bus.cpu.disassemble()` を経由してアーキテクチャ固有の逆アセンブラを利用する。
    - **スマートスクロール:** PCが変更された際、実行予定の「先（下）」が見えるように5行分のスクロールマージンを維持する。
