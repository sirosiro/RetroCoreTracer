# ARCHITECTURE MANIFEST - Retro Core Tracer (UI Layer)

---
## Part 1: このマニフェストの取扱説明書 (Guide)

### 1. 目的 (Purpose): なぜこの憲章が存在するのか

このドキュメントは、プロジェクト「Retro Core Tracer」の特定モジュール「UI Layer」の「北極星」です。開発者とAIが共有する高レベルな目標と、決して譲れない技術的・哲学的制約を定義します。その目的は、場当たり的な実装を防ぎ、モジュールが長期にわたって技術的負債を抱えることなく、クリーンなアーキテクチャを維持し続けることにあります。

これにより、AIは単なるコード生成ツールを超え、アーキテクチャ全体と一貫した、より洞察に富んだ提案が可能な、真の協調開発パートナーとして機能します。

### 2. 憲章の書き方 (Guidelines)

*   **原則1: 具体的に記述する。**
    *   悪い例: 「使いやすいUIにする」
    *   良い例: 「ステップ実行ボタンを押してから画面が更新されるまでの遅延は、50ms以内とする」のように、検証可能な目標を設定します。

*   **原則2: 「なぜ」に焦点を当てる。**
    *   ルールだけではなく、その背景にあるトレードオフの判断を明記します。これが憲章の形骸化を防ぎ、将来の変更を助けます。
    *   例: 「我々は、リッチなグラフィックスよりも、情報の密度と明瞭さを優先する。なぜなら、このツールのユーザーはエンジニアであり、正確な内部状態の把握を求めているからだ。」

*   **原則3: 「禁止」ではなく「判断の背景」を記述する。**
    *   「禁止事項」や「守るべきルール」といった思考停止を招く言葉を避け、「我々はこういう判断をした」といった形で、判断に至った文脈や背景そのものを記述します。
    *   例: 「現時点では、UIフレームワークとしてPySide6を採用する判断をした。これは、Qtの強力なウィジェットシステムとクロスプラットフォーム性を評価したためである。」

### 3. リスクと対策 (Risks and Mitigations)

*   **リスク:** ドキュメントが陳腐化し、現実のコードと乖離する。
    *   **対策:** アーキテクチャに影響を与えるコード変更（例: 新しいビューの追加、UIとコアの通信方法の変更）は、必ずこのマニフェストの更新とセットでレビューします。これは、`DESIGN_PHILOSOPHY.md`で定義された、AIと人間の双方が遵守すべき厳格なプロトコルです。

*   **リスク:** 全体原則と、特定のUI要件（局所的な要求）が衝突する。
    *   **対策:** 原則としてこの憲章を優先します。ただし、局所的なコード内コメントで明確な理由（例: 「パフォーマンス上の理由から、この特定の描画処理のみコアの内部データに直接アクセスしてキャッシュを作成する」）が示されている場合に限り、戦術的な逸脱を許容します。

---
## Part 2: マニフェスト本体 (Content)

### 1. 核となる原則 (Core Principles)

*このセクションは、モジュールの不変的なルールを「なぜ」の理由付けと共に定義します。*

<!--
- **原則: UIは、Snapshotオブジェクトのみを情報源として描画を行う。**
  - **理由:** コアロジックとの疎結合を維持し、"Time Travel Debugging"（過去のSnapshotの再生）のような機能を容易に実装できるようにするため。

- **原則: UIスレッドとエミュレーションスレッドは分離されるべきである（将来的な目標）。**
  - **理由:** 重いエミュレーション処理や大量のログ出力が、UIの応答性を阻害しないようにするため。現時点ではシングルスレッドかもしれないが、設計はこれを考慮しておく。
-->

### 2. 主要なアーキテクチャ決定の記録 (Key Architectural Decisions)

*このセクションは、「なぜこの構造になったのか」を後から追えるように、重要な設計判断をログとして残します。*

<!--
- **Date:** 2026-02-05
- **Core Principle:** UIは、Snapshotオブジェクトのみを情報源として描画を行う。
- **Decision:** PySide6 (Qt for Python) を採用する。
- **Rationale:** 成熟したウィジェットツールキットであり、デスクトップアプリケーションとしての品質（高DPI対応、ネイティブなルックアンドフィール）を確保しやすいため。
- **Alternatives:**
  - Tkinter: 標準ライブラリだが、モダンなUI構築には不向き。
  - Webベース (Electron/React): 開発効率は良いが、Pythonバックエンドとの通信オーバーヘッドや、配布の複雑さがある。
- **Consequences:** Qtの学習コストがかかる。ライセンス（LGPL）に留意する必要がある。
-->

### 3. モジュール構成 (Module Structure)

*このセクションは、モジュール内部の構造を定義します。*

- **`app.py`**: アプリケーションのエントリーポイント。Qtアプリケーションの初期化を行う。
- **`main_window.py`**: メインウィンドウのレイアウトと、各ウィジェットの配置を管理する。
- **`fonts.py`**: クロスプラットフォームなフォント選択ロジックを提供するユーティリティ。
- **`hex_view.py`**: メモリダンプを表示するウィジェット。
- **`register_view.py`**: レジスタ値を表示するウィジェット。
- **`flag_view.py`**: フラグ状態を表示するウィジェット。
- **`stack_view.py`**: スタックメモリを表示するウィジェット。
- **`breakpoint_view.py`**: ブレークポイント管理ウィジェット。

### 4. コンポーネント設計仕様 (Component Design Specifications)

*このセクションは、このマニフェストを元に、AIが人間と協調して機能的に同等なコードを再実装できるように、システムの主要コンポーネントの「設計仕様」を定義します。このセクションは、まず空のプレースホルダーとして生成され、人間とAIの対話を通じて合意形成をしながら埋めていくことを想定しています。単なる要約に留まらず、第三者がマニフェストを読むだけで具体的な実装をイメージできるレベルまで、各コンポーネントの責務、APIのシグネチャ（引数、戻り値を含む）、データ構造、重要なアルゴリズム、状態遷移を詳細に記述することが極めて重要です。*

#### 4.1. App (Entry Point)
- **責務 (Responsibility):** アプリケーションのライフサイクルを管理し、`QApplication`インスタンスと`MainWindow`を初期化して起動する。
- **提供するAPI (Public API):**
    - `main() -> None`: アプリケーションのエントリーポイント関数。

#### 4.2. MainWindow (メインウィンドウ)
- **責務 (Responsibility):** アプリケーションのメインウィンドウとして機能し、以下の責務を負う。
    - バックエンド（Bus, CPU, Debugger）の初期化と保持。
    - **ドッキングレイアウトの管理:** 各ビューを `QDockWidget` として管理し、ユーザーが自由に配置（上下分割、タブ化）できる柔軟なレイアウトを提供。
    - ユーザーアクション（メニュー、ツールバー）のハンドリング。
    - デバッガの実行制御（Run, Stop, Step）と、スナップショットに基づく全UIコンポーネントの更新調整。
    - **ステータス表示:** ステータスバーを利用し、現在の累積サイクル数（T-States）や実行状態をユーザーにフィードバックする。
- **主要なデータ構造 (Key Data Structures):**
    - `bus: Bus`: システムバスインスタンス。
    - `cpu: Z80Cpu`: エミュレート対象のCPUインスタンス。
    - `debugger: Debugger`: デバッガインスタンス。
    - `debugger_thread: DebuggerThread`: デバッガをバックグラウンドで実行するためのスレッド。
    - **Dock Widgets:** 各種ビュー（Code, Hex, Stack, Register, etc.）をラップした `QDockWidget` 群。
- **重要なアルゴリズム (Key Algorithms):**
    - **非同期デバッグ実行:** `DebuggerThread`を使用してデバッガの`run()`メソッドを実行し、UIのフリーズを防ぐ。ブレークポイントヒット時にシグナルを受け取り、UIを更新する。
    - **動的レイアウト制御:** `splitDockWidget` と `tabifyDockWidget` を使用して初期状態の上下分割とタブ配置を構築。`View` メニューにより各ドックの表示/非表示を切り替え可能。

#### 4.3. HexView (メモリビュー)
- **責務 (Responsibility):** メモリの内容を16進数およびASCII形式で表示する。指定されたアドレス（例：PC）をハイライト表示する機能を持つ。
- **設計上の決定:** メモリ読み込みには `Bus.peek()` を使用し、シミュレータのバスアクティビティログを汚染しないようにする。
- **提供するAPI (Public API):**
    - `update_memory(bus: Bus, start_address: int, length: int, highlight_address: Optional[int]) -> None`:
        - 指定された範囲のメモリをバスから読み込み、表示を更新する。`highlight_address`が指定された場合、該当行を強調表示する。

#### 4.4. RegisterView (レジスタビュー)
- **責務 (Responsibility):** Z80 CPUのレジスタ（メイン、代替、インデックス、特殊）の現在の値を表示する。
- **提供するAPI (Public API):**
    - `update_registers(snapshot: Snapshot) -> None`:
        - スナップショットに含まれる`CpuState`からレジスタ値を抽出し、各ラベルを更新する。

#### 4.5. FlagView (フラグビュー)
- **責務 (Responsibility):** Z80 CPUのフラグレジスタ（F）の個々のビット（S, Z, H, PV, N, C）の状態を視覚的に表示する。
- **提供するAPI (Public API):**
    - `update_flags(snapshot: Snapshot) -> None`:
        - スナップショットからフラグの状態を取得し、表示（0/1）を更新する。

#### 4.6. StackView (スタックビュー)
- **責務 (Responsibility):** 現在のスタックポインタ（SP）周辺のメモリ内容を表示し、スタックの成長や変化を可視化する。
- **提供するAPI (Public API):**
    - `update_stack(bus: Bus, sp_address: int) -> None`:
        - SPを中心としたメモリ領域をバスから読み込み、HEXダンプ形式で表示する。SPの位置をハイライトする。

#### 4.7. BreakpointView (ブレークポイント管理ビュー)
- **責務 (Responsibility):** ブレークポイントの追加、削除、一覧表示を行うインターフェースを提供する。
- **提供するAPI (Public API):**
    - `set_breakpoints(breakpoints: List[BreakpointCondition]) -> None`:
        - 現在設定されているブレークポイントのリストを受け取り、一覧表示を更新する。
    - **Signals:**
        - `breakpoint_added(BreakpointCondition)`: ユーザーが新しいブレークポイントを追加したときに発行される。
        - `breakpoint_removed(BreakpointCondition)`: ユーザーがブレークポイントを削除したときに発行される。

#### 4.8. CodeView (コードビュー)
- **責務 (Responsibility):** メモリ上の機械語を逆アセンブルして表示し、現在のプログラムカウンタ (PC) の位置を視覚的に強調する。
- **提供するAPI (Public API):**
    - `update_code(bus: Bus, pc: int) -> None`:
        - 指定されたPC周辺のコードを逆アセンブルし、テーブルを更新する。PCに該当する行をハイライト表示する。
    - `reset_cache(self) -> None`:
        - 内部で保持している逆アセンブル結果のキャッシュをクリアする。メモリ内容が大幅に変更された（例：新しいプログラムのロード）際に呼び出す必要がある。
- **主要なデータ構造 (Key Data Structures):**
    - `disassembled_data: List[Tuple[int, str, str]]`: 現在テーブルに表示しているアドレス、16進数、ニーモニックのキャッシュ。
- **重要なアルゴリズム (Key Algorithms):**
    - **効率的な表示更新 (Caching):**
        - 現在のPCを基準に前後4096バイト（4KB）の範囲を逆アセンブルして表示する。
        - 新しく指定された `pc` が `disassembled_data` の範囲内に存在する場合、テーブルの再構築をスキップし、ハイライト位置の移動のみを行う。
        - これにより、ステップ実行時に不要な画面のちらつきを抑え、パフォーマンスを向上させる。
    - **スマートスクロール (Scroll Control):**
        - `pc` が変更された際、`scrollToItem` を使用してハイライト行が画面内に見えるように制御する。
        - スクロールマージン（5行分）を設定し、ハイライト行が画面の下端に到達する前にスクロールを開始することで、常に実行予定の次行が見える状態を維持する。
        - PCが画面内にある間はスクロール位置を維持し、画面外に移動した場合のみ必要最小限のスクロールを行うことで、安定したコード閲覧環境を提供する。