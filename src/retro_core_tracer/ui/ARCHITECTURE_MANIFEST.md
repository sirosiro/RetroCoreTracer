# src/retro_core_tracer/ui/ARCHITECTURE_MANIFEST.md

---
## Part 1: このマニフェストの取扱説明書 (Guide)

### 1. 目的 (Purpose): なぜこの憲章が存在するのか

このドキュメントは、プロジェクト「Retro Core Tracer」の特定モジュール「UI Layer」の「北極星」です。開発者とAIが共有する高レベルな目標と、決して譲れない技術的・哲学的制約を定義します。その目的は、場当たり的な実装を防ぎ、モジュールが長期にわたって技術的負債を抱えることなく、クリーンなアーキテクチャを維持し続けることにあります。

これにより、AIは単なるコード生成ツールを超え、アーキテクチャ全体と一貫した、より洞察に富んだ提案が可能な、真の協調開発パートナーとして機能します。

### 2. 憲章の書き方 (Guidelines)

*   **原則1: 具体的に記述する。**
    *   良い例: 「ステップ実行ボタンを押してから画面が更新されるまでの遅延は、50ms以内とする」のように、検証可能な目標を設定します。

*   **原則2: 「なぜ」に焦点を当てる。**
    *   ルールだけではなく、その背景にあるトレードオフの判断を明記します。これが憲章の形骸化を防ぎ、将来の変更を助けます。

*   **原則3: 「禁止」ではなく「判断の背景」を記述する。**
    *   「禁止事項」や「守るべきルール」といった思考停止を招く言葉を避け、「我々はこういう判断をした」といった形で、判断に至った文脈や背景そのものを記述します。

### 3. リスクと対策 (Risks and Mitigations)

*   **リスク:** ドキュメントが陳腐化し、現実のコードと乖離する。
    *   **対策:** アーキテクチャに影響を与えるコード変更は、必ずこのマニフェストの更新とセットでレビューします。

---
## Part 2: マニフェスト本体 (Content)

### 1. 核となる原則 (Core Principles)

- **原則: UIは特定のCPUアーキテクチャの実装詳細を知ってはならない。**
  - **理由:** マルチアーキテクチャ対応を容易にし、CPUの追加時にUIコードの修正を不要にするため。UIは `AbstractCpu` が提供するメタデータ（レイアウト、レジスタマップ、フラグ状態、`has_io_port` フラグ）のみに基づいて描画を行う。

- **原則: UIコンポーネントは、統一された初期化・更新インターフェースを持つ。**
  - **理由:** `MainWindow` が各ビューを一貫した方法で管理（Dependency Injectionおよび描画更新）できるようにし、結合度を下げるため。具体的には `set_context` (または `set_cpu`/`set_bus`) と `update_view` パターンを採用する。

- **原則: UIの演出（アニメーション）は、CPUの実行タイミングから非同期に行われる。**
  - **理由:** CPUコアの実行速度をUI描画が阻害しないようにするため。また、一瞬で終わるCPUの計算プロセスを、人間が理解できる速度で「後追い再生（Replay）」することで、教育的な効果を高めるため。

### 2. 主要なアーキテクチャ決定 of 記録 (Key Architectural Decisions)

- **Date:** 2026-02-11
- **Core Principle:** 教育のための透明性。
- **Decision:** `CoreCanvas` にパストレース型のアニメーション機能を導入する。
- **Rationale:** データの流れを単なる直線移動ではなく、画面上に描画されたバス配線に沿って移動させることで、コンピュータの電気的な動作をより直感的に理解できるようにするため。

- **Date:** 2026-02-11
- **Core Principle:** 設定駆動型レイアウト。
- **Decision:** バス配線の座標とアニメーションパスを同一の計算ロジックから生成する。
- **Rationale:** システム構成（Memory Map/IO Map）によってデバイスの配置が変わっても、アニメーションが常に正確に配線上をトレースすることを保証するため。

### 3. モジュール構成 (Module Structure)

- **`core_canvas.py`**: CPU、バス、メモリ、IOの動的なブロック図とパストレースアニメーションを管理する。

### 4. コンポーネント設計仕様 (Component Design Specifications)

#### 4.9. CoreCanvas (ビジュアライザー)
- **責務:**
    - CPUの内部構造、バス（アドレス/データ）、メモリ、IOをグラフィカルに描画する。
    - `SystemConfig` に基づき、メモリマップとIOマップを静的に描画する。
    - `Snapshot` に記録された `bus_activity` を解析し、バス配線に沿ったアニメーションを再生する。
    - **アーキテクチャ対応:** `cpu.has_io_port` プロパティを参照し、I/Oポート表示の有無を動的に切り替える。
- **提供するAPI:**
    - `set_cpu(cpu: AbstractCpu)`
    - `set_config(config: SystemConfig)`
    - `update_view(snapshot: Snapshot)`
- **重要なアルゴリズム:**
    - **パス計算:** デバイスの種類（Memory/IO）とアクセスタイプ（READ/WRITE）に応じて、CPUのデータポートから対象デバイスまでの折れ線経路（座標リスト）を算出する。
    - **パストレース:** `BusSignal` は、保持している座標リストを `progress` (0.0 - 1.0) に基づいて線形補間し、経由地（Waypoint）を順番に辿ることで、曲がった配線上を移動する。