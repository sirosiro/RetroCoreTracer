# ARCHITECTURE MANIFEST - Retro Core Tracer (Transport Layer)

---
## Part 1: このマニフェストの取扱説明書 (Guide)

### 1. 目的 (Purpose): なぜこの憲章が存在するのか

このドキュメントは、プロジェクト「Retro Core Tracer」の特定モジュール「Transport Layer」の「北極星」です。開発者とAIが共有する高レベルな目標と、決して譲れない技術的・哲学的制約を定義します。その目的は、場当たり的な実装を防ぎ、モジュールが長期にわたって技術的負債を抱えることなく、クリーンなアーキテクチャを維持し続けることにあります。

これにより、AIは単なるコード生成ツールを超え、アーキテクチャ全体と一貫した、より洞察に富んだ提案が可能な、真の協調開発パートナーとして機能します。

### 2. 憲章の書き方 (Guidelines)

*   **原則1: 具体的に記述する。**
    *   悪い例: 「高速であるべき」
    *   良い例: 「バスの読み書き操作のP95応答時間は100ns未満に抑える」のように、検証可能な目標を設定します。

*   **原則2: 「なぜ」に焦点を当てる。**
    *   ルールだけではなく、その背景にあるトレードオフの判断を明記します。これが憲章の形骸化を防ぎ、将来の変更を助けます。
    *   例: 「我々は、バスアクセス制御の厳密性よりも、様々なデバイスへの柔軟なマッピングを優先する。なぜなら、多種多様なレトロCPUの周辺回路をサポートする必要があるからだ。」

*   **原則3: 「禁止」ではなく「判断の背景」を記述する。**
    *   「禁止事項」や「守るべきルール」といった思考停止を招く言葉を避け、「我々はこういう判断をした」といった形で、判断に至った文脈や背景そのものを記述します。
    *   例: 「現時点では、バスは同期的な読み書きインターフェースのみを提供する、という判断をした。これは、初期段階での実装の複雑性を抑え、コアロジックからの予測可能性を高めるためである。」

### 3. リスクと対策 (Risks and Mitigations)

*   **リスク:** ドキュメントが陳腐化し、現実のコードと乖離する。
    *   **対策:** アーキテクチャに影響を与えるコード変更（例: 新デバイスの追加、バスAPIの責務変更）は、必ずこのマニフェストの更新とセットでレビューします。これは、`DESIGN_PHILOSOPHY.md`で定義された、AIと人間の双方が遵守すべき厳格なプロトコルです。

*   **リスク:** 全体原則と、特定のデバイス（局所的な要求）が衝突する。
    *   **対策:** 原則としてこの憲章を優先します。ただし、局所的なコード内コメントで明確な理由（例: 「特定のI/Oポートは特殊なデータラッチ動作をするため、標準バスアクセスを逸脱」）が示されている場合に限り、戦術的な逸脱を許容します。

---
## Part 2: マニフェスト本体 (Content)

### 1. 核となる原則 (Core Principles)

*このセクションは、モジュールの不変的なルールを「なぜ」の理由付けと共に定義します。*

<!--
- **原則: バスアクセスは、アドレスとデータペイロードのみに限定される。**
  - **理由:** CPUコアからバスへのインターフェースをシンプルに保ち、下位レイヤー（デバイスドライバ）の複雑性を上位レイヤーに伝播させないため。

- **原則: メモリマップドI/Oを含む全てのアクセスは、単一のBusインターフェースを介して行われる。**
  - **理由:** CPUコア側がROM、RAM、I/Oを意識することなく、アドレス指定だけでアクセスを完結できるようにし、CPU実装の抽象度を高めるため。
-->

### 2. 主要なアーキテクチャ決定の記録 (Key Architectural Decisions)

*このセクションは、「なぜこの構造になったのか」を後から追えるように、重要な設計判断をログとして残します。*

<!--
- **Date:** 2026-02-05
- **Core Principle:** メモリマップドI/Oを含む全てのアクセスは、単一のBusインターフェースを介して行われる。
- **Decision:** Busクラス内部で、登録されたアドレス範囲とデバイスのマッピングを管理し、アクセス時に適切なデバイスへディスパッチするメカニズムを採用する。
- **Rationale:** 複数のCPUアーキテクチャに対応する際に、各CPUが持つ多様なメモリマップ構成に柔軟に対応するため。
- **Alternatives:**
  - 各デバイスが自身のメモリ範囲を直接公開し、CPUが直接アクセスする。→ CPU側でデバイスごとのアドレス解決ロジックが必要になり、CPU実装が複雑化する。
- **Consequences:** Busクラスがシステム全体のメモリマップ構成を一元的に管理する責務を負うため、Busクラス自体の設計が複雑になる可能性がある。
-->

### 3. AIとの協調に関する指針 (AI Collaboration Policy)

*このセクションは、AIがどう振る舞うべきかの指針を記述します。*

- **未知の問題への対処:** この憲章に記載のない問題に直面した際、AIは`DESIGN_PHILOSOPHY.md`の根本思想に立ち返り、複数の選択肢とそれぞれのトレードオフを提示し、人間の判断を仰いでください。
- **戦略（憲章）と戦術（コメント）の連携:** この憲章（戦略）と、コード内に記述されるインテント・コメント（戦術）は、一貫性を保つべきです。AIは、コード生成時にインテント・コメントの草案を提案する責務を負います。

### 4. コンポーネント設計仕様 (Component Design Specifications)

*このセクションは、このマニフェストを元に、AIが人間と協調して機能的に同等なコードを再実装できるように、システムの主要コンポーネントの「設計仕様」を定義します。このセクションは、まず空のプレースホルダーとして生成され、人間とAIの対話を通じて合意形成をしながら埋めていくことを想定しています。単なる要約に留めず、第三者がマニフェストを読むだけで具体的な実装をイメージできるレベルまで、各コンポーネントの責務、APIのシグネチャ（引数、戻り値を含む）、データ構造、重要なアルゴリズム、状態遷移を詳細に記述することが極めて重要です。*

#### 4.1. BusAccessType (Enum)
- **責務 (Responsibility):** バス上で発生する操作の種類（読み込みまたは書き込み）を明確に定義する。
- **主要なデータ構造 (Key Data Structures):**
    - `READ`: 読み込み操作
    - `WRITE`: 書き込み操作

#### 4.2. BusAccess (データクラス)
- **責務 (Responsibility):** バス上で行われた個々のアクセス操作（アドレス、データ、タイプ）を不変な形式で記録する。これにより、システムの観測可能性とデバッグ時のトレーサビリティを確保する。
- **主要なデータ構造 (Key Data Structures):**
    - `address: int`: アクセスされたメモリまたはI/Oアドレス（8bit幅を想定）。
    - `data: int`: 読み書きされた8bitデータ。
    - `access_type: BusAccessType`: アクセスの種類（読み込み/書き込み）。
- **状態とライフサイクル (State and Lifecycle):** インスタンス生成後に状態は変更されない不変（immutable）なデータ構造である。

#### 4.3. Device (抽象基底クラス)
- **責務 (Responsibility):** バスに接続される全てのメモリマップドデバイス、またはI/Oデバイスが実装すべき標準インターフェースを定義する。これにより、バスとデバイス間の疎結合を保証し、多様なデバイスの統合を可能にする。
- **提供するAPI (Public API):**
    - `read(self, address: int) -> int`:
        - **責務:** 指定されたデバイス内アドレスから8bitのデータを読み出す。アドレスはデバイス自身のオフセットとして解釈される。
        - **引数:** `address` (int) - デバイス内のオフセットアドレス。
        - **戻り値:** `int` - 読み出された8bitデータ。
    - `write(self, address: int, data: int) -> None`:
        - **責務:** 指定されたデバイス内アドレスに8bitのデータを書き込む。
        - **引数:**
            - `address` (int) - デバイス内のオフセットアドレス。
            - `data` (int) - 書き込む8bitデータ。
        - **戻り値:** `None`。
- **状態とライフサイクル (State and Lifecycle):** 具象デバイスは、自身の内部状態と、与えられたアドレスに対するオフセットの管理を責務とする。

#### 4.4. RAM (具象デバイス)
- **責務 (Responsibility):** 指定されたサイズで初期化される、基本的なランダムアクセスメモリ機能を提供する。バスシステムのテストや、エミュレート対象システムのメインメモリとして機能する。
- **提供するAPI (Public API):**
    - `__init__(self, size: int)`:
        - **責務:** 指定されたバイトサイズのメモリ領域を初期化する。
        - **引数:** `size` (int) - RAMの合計サイズ（バイト単位）。
        - **前提条件:** `size`は正の整数である必要がある。
    - `read(self, address: int) -> int`:
        - **責務:** 指定されたデバイス内オフセットアドレスから8bitのデータを読み出す。
        - **前提条件:** `address`はRAMの有効範囲内である必要がある。
    - `write(self, address: int, data: int) -> None`:
        - **責務:** 指定されたデバイス内オフセットアドレスに8bitのデータを書き込む。
        - **前提条件:** `address`はRAMの有効範囲内であり、`data`は8bit値（0〜255）である必要がある。
    - `get_size(self) -> int`:
        - **責務:** 現在のRAMデバイスのサイズを返す。
- **主要なデータ構造 (Key Data Structures):**
    - `_memory: bytearray`: 実際のメモリ内容を保持するバイト配列。
    - `_size: int`: RAMデバイスの総サイズ。
- **状態とライフサイクル (State and Lifecycle):** インスタンス化時に`size`が決定され、内部の`_memory`配列を通じてデータの読み書きが行われる。

#### 4.5. Bus (主要コンポーネント)
- **責務 (Responsibility):**
    - システム全体のメモリアドレス空間を一元的に管理する。
    - 登録されたデバイスへの読み書きアクセスを適切なアドレス範囲に基づいてディスパッチする。
    - **I/O空間アクセス:** `read_io` および `write_io` インターフェースを提供し、Z80などの独立I/O空間を持つCPUからのポート操作を受け付ける（現状はログ記録のみでマッピングは未実装）。
    - バス上で行われる全てのアクセス操作（読み書き、I/O）を`BusAccess`オブジェクトとして記録し、外部から取得可能にする（オブザーバビリティの提供）。
- **提供するAPI (Public API):**
    - `__init__(self)`:
        - **責務:** バスインスタンスを初期化し、空のメモリマップとバスアクセスログを準備する。
    - `register_device(self, start_address: int, end_address: int, device: Device) -> None`:
        - **責務:** 指定された開始アドレスから終了アドレスの範囲にデバイスを登録する。
        - **引数:**
            - `start_address` (int) - デバイスがマップされる開始アドレス。
            - `end_address` (int) - デバイスがマップされる終了アドレス。
            - `device` (Device) - バスに登録するデバイスインスタンス。
        - **前提条件:**
            - `start_address <= end_address` かつ非負であること。
            - `device`は`Device`抽象基底クラスのインスタンスであること。
            - `RAM`デバイスの場合、その`size`が指定されたアドレス範囲と一致すること。
        - **設計上の決定:** アドレス範囲の重複チェックは行わない。これはバスの責務ではなく、システム設計のより上位の層で管理されるべきと判断された。
    - `read(self, address: int) -> int`:
        - **責務:** 指定された物理アドレスから8bitのデータを読み出す。対応するデバイスを見つけ、その`read`メソッドを呼び出し、アクセスをログに記録する。
        - **前提条件:** `address`はマップされたデバイスの有効範囲内である必要がある。
    - `write(self, address: int, data: int) -> None`:
        - **責務:** 指定された物理アドレスに8bitのデータを書き込む。対応するデバイスを見つけ、その`write`メソッドを呼び出し、アクセスをログに記録する。
        - **前提条件:** `address`はマップされたデバイスの有効範囲内であり、`data`は8bit値（0〜255）である必要がある。
    - `peek(self, address: int) -> int`:
        - **責務:** 指定された物理アドレスから8bitのデータを読み出すが、**アクセスログには記録しない**。
        - **用途:** UIコンポーネント（HexView, StackViewなど）が、シミュレーションの状態（バスログ）に影響を与えずにメモリ内容を表示するために使用する。
    - `read_io(self, address: int) -> int`:
        - **責務:** 指定されたI/Oポートアドレスから8bitのデータを読み出し、ログに記録する。
    - `write_io(self, address: int, data: int) -> None`:
        - **責務:** 指定されたI/Oポートアドレスに8bitのデータを書き込み、ログに記録する。
    - `get_and_clear_activity_log(self) -> List[BusAccess]`:
        - **責務:** 現在までに記録された全てのバスアクセスログをリストとして返し、内部ログをクリアする。
        - **保証事項:** 返されるリスト内の `BusAccess` オブジェクトは、実際のバスアクセスが発生した時系列順（発生順）に格納されていなければならない。これは「Bus Glow」などの可視化機能が、データの流れを正しい順序で再生するために不可欠である。
        - **戻り値:** `List[BusAccess]` - 記録されたバスアクセス操作のリスト。
- **主要なデータ構造 (Key Data Structures):**
    - `_memory_map: List[Tuple[int, int, Device]]`: バスに登録された各デバイスのアドレス範囲とデバイスインスタンスを格納するリスト。タプルは`(開始アドレス, 終了アドレス, デバイスインスタンス)`の形式。
    - `_bus_activity_log: List[BusAccess]`: 実行された全てのバスアクセス操作を記録するリスト。
- **重要なアルゴリズム (Key Algorithms):**
    - **アドレスディスパッチ (`_find_device`):**
        - **責務:** 与えられた物理アドレスに対応する登録済みデバイスと、そのデバイス内でのオフセットアドレスを線形探索で見つけ出す。
        - **アルゴリズム:** `_memory_map`リストを線形に走査し、`start_address <= address <= end_address`を満たす最初のデバイスを返す。
        - **エラーハンドリング:** マップされていないアドレスが指定された場合は`IndexError`を発生させる。
- **状態とライフサイクル (State and Lifecycle):**
    - バスはアプリケーションの初期化時に構成され、デバイスが登録されることで`_memory_map`が構築される。
    - `_bus_activity_log`は`get_and_clear_activity_log`が呼び出されるたびにクリアされ、新たなアクセスログが記録される。