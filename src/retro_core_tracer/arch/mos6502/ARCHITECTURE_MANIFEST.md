# ARCHITECTURE MANIFEST - Retro Core Tracer (MOS 6502 Architecture Layer)

---
## Part 1: このマニフェストの取扱説明書 (Guide)

### 1. 目的 (Purpose): なぜこの憲章が存在するのか

このドキュメントは、プロジェクト「Retro Core Tracer」の特定モジュール「MOS 6502 Architecture Layer」の「北極星」です。開発者とAIが共有する高レベルな目標と、決して譲れない技術的・哲学的制約を定義します。その目的は、場当たり的な実装を防ぎ、モジュールが長期にわたって技術的負債を抱えることなく、クリーンなアーキテクチャを維持し続けることにあります。

これにより、AIは単なるコード生成ツールを超え、アーキテクチャ全体と一貫した、より洞察に富んだ提案が可能な、真の協調開発パートナーとして機能します。

### 2. 憲章の書き方 (Guidelines)

*   **原則1: 具体的に記述する。**
    *   悪い例: 「高速であるべき」
    *   良い例: 「1命令あたりの実行オーバーヘッドは、ネイティブ実行時間の500%未満に抑える」のように、検証可能な目標を設定します。

*   **原則2: 「なぜ」に焦点を当てる。**
    *   ルールだけではなく、その背景にあるトレードオフの判断を明記します。これが憲章の形骸化を防ぎ、将来の変更を助けます。
    *   例: 「我々は、UIの応答性よりもエミュレーションの正確性を優先する。なぜなら、このプロジェクトの第一目的は教育的な透明性の確保だからだ。」

*   **原則3: 「禁止」ではなく「判断の背景」を記述する。**
    *   「禁止事項」や「守るべきルール」といった思考停止を招く言葉を避け、「我々はこういう判断をした」といった形で、判断に至った文脈や背景そのものを記述します。
    *   例: 「現時点では、コアロジックとUIの結合を避けるため、両者はSnapshotオブジェクトを通してのみ通信する、という判断をした。」

### 3. リスクと対策 (Risks and Mitigations)

*   **リスク:** ドキュメントが陳腐化し、現実のコードと乖離する。
    *   **対策:** アーキテクチャに影響を与えるコード変更（例: 新コンポーネントの追加、既存APIの責務変更）は、必ずこのマニフェストの更新とセットでレビューします。これは、`DESIGN_PHILOSOPHY.md`で定義された、AIと人間の双方が遵守すべき厳格なプロトコルです。

*   **リスク:** 全体原則と、特定のCPUアーキテクチャ（局所的な要求）が衝突する。
    *   **対策:** 原則としてこの憲章を優先します。ただし、局所的なコード内コメントで明確な理由（例: 「6809の特殊なアドレッシングモードのため、標準バスアクセスを逸脱」）が示されている場合に限り、戦術的な逸脱を許容します。

---
## Part 2: マニフェスト本体 (Content)

### 1. 核となる原則 (Core Principles)

- **原則: スタックポインタ(SP)の可視化において、物理アドレスへのマッピング補正をCore層で行う。**
  - **理由:** 6502のSPは8ビットレジスタだが、物理的には固定ページ `$0100-$01FF` にマッピングされる。UI層（StackView）がアーキテクチャ固有の計算式を知らなくても正しいアドレスを表示できるよう、`AbstractCpu.get_state()` が返す `sp` 値は、このオフセット（`0x0100`）を加算した物理アドレスとする。内部ロジックでは8ビットとして扱う。

- **原則: 実機の既知のバグ（JMP Indirectラップアラウンド等）を正確に再現する。**
  - **理由:** 本プロジェクトの目的は「計算の本質」と「歴史的ハードウェアの挙動」を学ぶことにあるため。バグを修正した理想的なCPUではなく、実際に存在したシリコンの挙動をシミュレートする。

- **原則: BCD（2化10進数）演算を正確にサポートする。**
  - **理由:** 6502の特徴的な機能であり、多くのゲームやアプリケーションがこの機能に依存しているため。`D` フラグの状態に応じた演算ロジックの切り替えを実装する。

### 2. 主要なアーキテクチャ決定の記録 (Key Architectural Decisions)

- **Date:** 2026-02-14
- **Decision:** MOS 6502の実装を開始。
- **Rationale:** Z80 (Little Endian, Separate I/O), MC6800 (Big Endian, Memory Mapped I/O) に続く第3の主要アーキテクチャとして、6502 (Little Endian, Memory Mapped I/O) を加えることで、RCTの汎用性を実証し、教育的価値を高めるため。

### 3. モジュール構成 (Module Structure)

- **`cpu.py`**: `AbstractCpu` を継承したメイン実装。
- **`state.py`**: A, X, Y, PC, S, P レジスタおよびフラグの状態定義。
- **`instructions/`**:
    - **`base.py`**: アドレッシングモード（Immediate, Zero Page, Absolute, Indexed, Indirect等）の解決ロジックを集約。
    - **`maps.py`**: オペコードのマッピング。
    - **`load.py`**: 転送命令。
    - **`alu.py`**: 演算命令（BCD対応含む）。
    - **`control.py`**: 分岐、スタック、システム制御。
- **`disassembler.py`**: MOS 6502固有の逆アセンブラ。

### 4. コンポーネント設計仕様 (Component Design Specifications)

#### 4.1. Mos6502CpuState
- **責務:** 6502のレジスタ状態を保持する。
- **データ構造:**
    - `a`, `x`, `y`: 8ビットレジスタ。
    - `p`: 8ビットステータスレジスタ (NV-BDIZC)。
    - **注意:** `pc` と `sp` (8bit幅だが内部保持用) は `CpuState` 基底クラスのフィールドを利用するが、`sp` の扱いに注意が必要（原則参照）。

#### 4.2. Mos6502Cpu
- **責務:** `AbstractCpu` のインターフェースを実装する。
- **アドレッシングモード:**
    - 多くの命令で共通する複雑なアドレッシング（特に `Indirect Indexed` など）は、`instructions.base` モジュールに切り出して再利用性を高める。
- **サイクル計算:**
    - ページ境界（Page Boundary）を跨ぐアクセスが発生した場合のペナルティ（+1サイクル）を検出し、`Snapshot.metadata` に反映させる。