# ARCHITECTURE MANIFEST - Retro Core Tracer (Z80 Architecture Layer)

---
## Part 1: このマニフェストの取扱説明書 (Guide)

### 1. 目的 (Purpose): なぜこの憲章が存在するのか

このドキュメントは、プロジェクト「Retro Core Tracer」の特定モジュール「Z80 Architecture Layer」の「北極星」です。開発者とAIが共有する高レベルな目標と、決して譲れない技術的・哲学的制約を定義します。その目的は、場当たり的な実装を防ぎ、モジュールが長期にわたって技術的負債を抱えることなく、クリーンなアーキテクチャを維持し続けることにあります。

これにより、AIは単なるコード生成ツールを超え、アーキテクチャ全体と一貫した、より洞察に富んだ提案が可能な、真の協調開発パートナーとして機能します。

### 2. 憲章の書き方 (Guidelines)

*   **原則1: 具体的に記述する。**
    *   悪い例: 「高速であるべき」
    *   良い例: 「Z80の1命令あたりの実行オーバーヘッドは、ネイティブ実行時間の500%未満に抑える」のように、検証可能な目標を設定します。

*   **原則2: 「なぜ」に焦点を当てる。**
    *   ルールだけではなく、その背景にあるトレードオフの判断を明記します。これが憲章の形骸化を防ぎ、将来の変更を助けます。
    *   例: 「我々は、UIの応答性よりもエミュレーションの正確性を優先する。なぜなら、このプロジェクトの第一目的は教育的な透明性の確保だからだ。」

*   **原則3: 「禁止」ではなく「判断の背景」を記述する。**
    *   「禁止事項」や「守るべきルール」といった思考停止を招く言葉を避け、「我々はこういう判断をした」といった形で、判断に至った文脈や背景そのものを記述します。
    *   例: 「現時点では、コアロジックとUIの結合を避けるため、両者はSnapshotオブジェクトを通してのみ通信する、という判断をした。」

### 3. リスクと対策 (Risks and Mitigations)

*   **リスク:** ドキュメントが陳腐化し、現実のコードと乖離する。
    *   **対策:** アーキテクチャに影響を与えるコード変更（例: 新コンポーネントの追加、既存APIの責務変更）は、必ずこのマニフェストの更新とセットでレビューします。これは、`DESIGN_PHILOSOPHY.md`で定義された、AIと人間の双方が遵守すべき厳格なプロトコルです。

*   **リスク:** 全体原則と、特定のCPUアーキテクチャ（局所的な要求）が衝突する。
    *   **対策:** 原則としてこの憲章を優先します。ただし、局所的なコード内コメントで明確な理由（例: 「6809の特殊なアドレッシングモードのため、標準バスアクセスを逸脱」）が示されている場合に限り、戦術的な逸脱を許容します。

---
## Part 2: マニフェスト本体 (Content)

### 1. 核となる原則 (Core Principles)

*このセクションは、モジュールの不変的なルールを「なぜ」の理由付けと共に定義します。*

<!--
- **原則: Z80エミュレーションは、公式ドキュメント（Zilog Z80 CPU User's Manual）の動作に厳密に準拠する。**
  - **理由:** エミュレーションの正確性を最優先するため。特にフラグの挙動、レジスタ操作、メモリ/I/Oアクセスのタイミングとデータは厳密に再現されるべきである。

- **原則: 命令のデコードと実行ロジックは、Instruction Layerの責務であり、Z80Cpuクラスはそれらをオーケストレーションする。**
  - **理由:** Core Layerで定義された抽象CPUの原則に準拠し、Z80固有の複雑な命令セットを管理しやすくするため。
-->

### 2. 主要なアーキテクチャ決定の記録 (Key Architectural Decisions)

*このセクションは、「なぜこの構造になったのか」を後から追えるように、重要な設計判断をログとして残します。*

<!--
- **Date:** 2026-02-05
- **Core Principle:** Z80エミュレーションは、公式ドキュメントの動作に厳密に準拠する。
- **Decision:** Z80のレジスタセットとフラグレジスタの特定のビット位置を正確にモデル化する`Z80State`クラスを導入する。
- **Rationale:** Z80の複雑なフラグ操作（特に演算結果に基づくHフラグやNフラグの更新）を正確にシミュレートするためには、これらのレジスタの状態をビットレベルで厳密に管理する必要がある。
- **Alternatives:**
  - 汎用的な`CpuState`をそのまま使用し、Z80固有のレジスタをフィールドとして追加する。→ フラグ操作のロジックが`Z80Cpu`クラス内に散在し、可読性と保守性が低下する。
- **Consequences:** `Z80State`が`CpuState`を継承し、Z80固有のレジスタとフラグ管理ロジックを持つことになる。
-->

### 3. AIとの協調に関する指針 (AI Collaboration Policy)

*このセクションは、AIがどう振る舞うべきかの指針を記述します。*

- **未知の問題への対処:** この憲章に記載のない問題に直面した際、AIは`DESIGN_PHILOSOPHY.md`の根本思想に立ち返り、複数の選択肢とそれぞれのトレードオフを提示し、人間の判断を仰いでください。
- **戦略（憲章）と戦術（コメント）の連携:** この憲章（戦略）と、コード内に記述されるインテント・コメント（戦術）は、一貫性を保つべきです。AIは、コード生成時にインテント・コメントの草案を提案する責務を負います。

### 4. コンポーネント設計仕様 (Component Design Specifications)

*このセクションは、このマニフェストを元に、AIが人間と協調して機能的に同等なコードを再実装できるように、システムの主要コンポーネントの「設計仕様」を定義します。このセクションは、まず空のプレースホルダーとして生成され、人間とAIの対話を通じて合意形成をしながら埋めていくことを想定しています。単なる要約に留めず、第三者がマニフェストを読むだけで具体的な実装をイメージできるレベルまで、各コンポーネントの責務、APIのシグネチャ（引数、戻り値を含む）、データ構造、重要なアルゴリズム、状態遷移を詳細に記述することが極めて重要です。*

#### 4.1. Z80CpuState (データクラス)
- **責務 (Responsibility):** `CpuState`を拡張し、Z80 CPU固有の全てのレジスタ（主レジスタ、代替レジスタ、インデックスレジスタ、特殊用途レジスタ）とフラグビットの状態を保持する。
- **主要なデータ構造 (Key Data Structures):**
    - **フラグビットマスク:** `S_FLAG` (Sign), `Z_FLAG` (Zero), `H_FLAG` (Half Carry), `PV_FLAG` (Parity/Overflow), `N_FLAG` (Add/Subtract), `C_FLAG` (Carry) の各ビット位置を定義する定数。
    - **主レジスタ:** `a`, `b`, `c`, `d`, `e`, `h`, `l` (8ビットレジスタ), `f` (フラグレジスタ)。
    - **代替レジスタ:** `a_`, `b_`, `c_`, `d_`, `e_`, `h_`, `l_`, `f_`。
    - **インデックスレジスタ:** `ix`, `iy` (16ビットレジスタ)。
    - **特殊用途レジスタ:** `i` (割り込みベクタレジスタ), `r` (リフレッシュレジスタ)。
- **提供するAPI (Public API) - プロパティ:**
    - **フラグアクセサ:** `flag_s`, `flag_z`, `flag_h`, `flag_pv`, `flag_n`, `flag_c` (それぞれ`bool`型のゲッター/セッターを提供し、`f`レジスタの対応するビットを操作する)。
    - **16ビットレジスタペアアクセサ:** `af`, `bc`, `de`, `hl` (それぞれ`int`型のゲッター/セッターを提供し、対応する8ビットレジスタペアを操作する)。
- **状態とライフサイクル (State and Lifecycle):**
    - `Z80CpuState`のインスタンスは、Z80 CPUの可変状態を保持する。
    - `CpuState`からの継承により、`pc`と`sp`も管理される。

#### 4.2. Z80InstructionSet (概念的なモジュール、`instructions.py`に実装)
- **責務 (Responsibility):** Z80命令セットのデコードロジックと実行ロジックを定義し提供する。これにより、Z80CPUは`AbstractCpu`の抽象メソッドを実装できる。
- **提供するAPI (Public API):**
    - `decode_opcode(opcode: int, bus: Bus, pc: int) -> Operation`:
        - **責務:** 与えられたオペコードをZ80の命令としてデコードし、`Operation`オブジェクトを返す。マルチバイト命令の場合、`bus`を介してオペランドバイトをフェッチする。
        - **引数:**
            - `opcode` (int): デコード対象のオペコードバイト。
            - `bus` (Bus): オペランドフェッチのためのバスインスタンス。
            - `pc` (int): 現在のプログラムカウンタ（マルチバイトオペランドの読み込みに使用）。
        - **戻り値:** `Operation` - デコードされた命令の詳細を含むオブジェクト。
    - `execute_instruction(operation: Operation, state: Z80CpuState, bus: Bus) -> None`:
        - **責務:** デコードされたZ80命令を実行し、`Z80CpuState`を更新し、必要に応じて`Bus`を介したメモリ/I/O操作を行う。
        - **引数:**
            - `operation` (Operation): 実行対象の命令詳細。
            - `state` (Z80CpuState): 現在のZ80 CPUの状態。
            - `bus` (Bus): メモリ/I/O操作のためのバスインスタンス。
- **主要なデータ構造 (Key Data Structures):**
    - `DECODE_MAP: Dict[int, Callable[[Bus, int], Operation]]`: オペコードとそれに対応するデコード関数をマッピングする辞書。
    - `EXECUTE_MAP: Dict[int, Callable[[Z80CpuState, Bus, Operation], None]]`: オペコードとそれに対応する実行関数をマッピングする辞書。
- **重要なアルゴリズム (Key Algorithms):**
    - **命令デコード:** オペコードをキーとして`DECODE_MAP`から対応するデコード関数をルックアップし、実行する。マルチバイトオペランドは`bus`から直接読み込む。
    - **命令実行:** オペコードをキーとして`EXECUTE_MAP`から対応する実行関数をルックアップし、`Z80CpuState`と`Bus`を引数として実行する。
- **状態とライフサイクル (State and Lifecycle):** このモジュールはステートレスな関数群とマップで構成されており、`Z80CpuState`と`Bus`インスタンスを介して間接的にCPUの状態とシステムバスに作用する。

#### 4.3. Z80Cpu (具象CPUエミュレータ)
- **責務 (Responsibility):** `AbstractCpu`インターフェースをZ80プロセッサ向けに完全に実装し、Z80固有の`Z80CpuState`と`Z80InstructionSet`を利用して、フェッチ、デコード、実行の命令サイクルをオーケストレートする。
- **継承元:** `AbstractCpu`。
- **提供するAPI (Public API) - `AbstractCpu`からのオーバーライド:**
    - `_create_initial_state(self) -> Z80CpuState`:
        - **責務:** Z80 CPUの初期状態を表す`Z80CpuState`のインスタンスを生成して返す。
        - **設計上の決定:** Z80の一般的なリセット時の状態を反映したデフォルト値を設定。
    - `_fetch(self) -> int`:
        - **責務:** 現在の`Z80CpuState.pc`から、システムバス(`self._bus`)を介してオペコードバイトを読み出す。
    - `_decode(self, opcode: int) -> Operation`:
        - **責務:** `instructions`モジュールの`decode_opcode`関数を呼び出し、与えられたオペコードをデコードする。`bus`と`pc`情報も渡すことで、マルチバイトオペランドの処理を可能にする。
    - `_execute(self, operation: Operation) -> None`:
        - **責務:** `instructions`モジュールの`execute_instruction`関数を呼び出し、デコードされた命令を実行する。`Z80CpuState`と`Bus`のインスタンスを渡すことで、命令がCPUの状態を変更したり、バスと相互作用したりできるようにする。
    - `step(self) -> Snapshot`:
        - **責務:** Z80 CPUを1命令サイクル分実行し、その結果を完全な`Snapshot`オブジェクトとして返す。
        - **処理フロー:**
            1. 実行前の`pc`を保存する。
            2. `self._bus.get_and_clear_activity_log()`を呼び出し、前サイクルのバスアクティビティをクリアする。
            3. `_fetch()`によりオペコードを取得する。
            4. `_decode()`によりオペコードをデコードし、`Operation`オブジェクトを得る。
            5. `operation.length`に基づいて`Z80CpuState.pc`をインクリメントし、次の命令の先頭を指すようにする。
            6. `_execute()`により命令を実行する。
            7. `self._bus.get_and_clear_activity_log()`を呼び出し、このサイクル中に発生した全てのバスアクティビティを取得する。
            8. 実行後の`Z80CpuState`、`Operation`、`Metadata`（`cycle_count`と`symbol_info`を含む）、および取得した`bus_activity`を含む`Snapshot`オブジェクトを構築し、返す。
- **主要なデータ構造 (Key Data Structures):**
    - `self._state: Z80CpuState`: `AbstractCpu`から継承されるCPUの状態。
- **重要なアルゴリズム (Key Algorithms):**
    - **命令サイクルオーケストレーション:** `step`メソッド内でフェッチ、デコード、PCインクリメント、実行、バスアクティビティキャプチャ、スナップショット生成の厳密な順序を管理する。
- **状態とライフサイクル (State and Lifecycle):** `Z80Cpu`インスタンスは、Z80エミュレーションの実行時コンテキスト全体を管理し、`AbstractCpu`のライフサイクルに従う。