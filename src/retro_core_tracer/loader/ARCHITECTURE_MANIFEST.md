# ARCHITECTURE MANIFEST - Retro Core Tracer (Loader Layer)

---
## Part 1: このマニフェストの取扱説明書 (Guide)

### 1. 目的 (Purpose): なぜこの憲章が存在するのか

このドキュメントは、プロジェクト「Retro Core Tracer」の特定モジュール「Loader Layer」の「北極星」です。開発者とAIが共有する高レベルな目標と、決して譲れない技術的・哲学的制約を定義します。その目的は、場当たり的な実装を防ぎ、モジュールが長期にわたって技術的負債を抱えることなく、クリーンなアーキテクチャを維持し続けることにあります。

これにより、AIは単なるコード生成ツールを超え、アーキテクチャ全体と一貫した、より洞察に富んだ提案が可能な、真の協調開発パートナーとして機能します。

### 2. 憲章の書き方 (Guidelines)

*   **原則1: 具体的に記述する。**
    *   悪い例: 「高速であるべき」
    *   良い例: 「Intel HEXファイルのパースは、1KBあたり10ms未満で完了する」のように、検証可能な目標を設定します。

*   **原則2: 「なぜ」に焦点を当てる。**
    *   ルールだけではなく、その背景にあるトレードオフの判断を明記します。これが憲章の形骸化を防ぎ、将来の変更を助けます。
    *   例: 「我々は、ロード可能なファイルフォーマットの多様性よりも、既存のバイナリ（Intel HEX）の正確なロードを優先する。なぜなら、レトロエミュレーションにおける主要な入力形式だからだ。」

*   **原則3: 「禁止」ではなく「判断の背景」を記述する。**
    *   「禁止事項」や「守るべきルール」といった思考停止を招く言葉を避け、「我々はこういう判断をした」といった形で、判断に至った文脈や背景そのものを記述します。
    *   例: 「現時点では、ローダーはメモリマップの重複を検知しないという判断をした。これはバスの責務であり、ローダーは単に指定されたアドレスにデータを書き込むことのみに注力する。」

### 3. リスクと対策 (Risks and Mitigations)

*   **リスク:** ドキュメントが陳腐化し、現実のコードと乖離する。
    *   **対策:** アーキテクチャに影響を与えるコード変更（例: 新しいファイルフォーマットのサポート、ローダーAPIの責務変更）は、必ずこのマニフェストの更新とセットでレビューします。これは、`DESIGN_PHILOSOPHY.md`で定義された、AIと人間の双方が遵守すべき厳格なプロトコルです。

*   **リスク:** 全体原則と、特定のロード要件（局所的な要求）が衝突する。
    *   **対策:** 原則としてこの憲章を優先します。ただし、局所的なコード内コメントで明確な理由（例: 「特定のバイナリフォーマットは自己展開型であるため、ロード後にエントリポイントへジャンプする特殊な処理が必要」）が示されている場合に限り、戦術的な逸脱を許容します。

---
## Part 2: マニフェスト本体 (Content)

### 1. 核となる原則 (Core Principles)

*このセクションは、モジュールの不変的なルールを「なぜ」の理由付けと共に定義します。*

<!--
- **原則: ローダーは、システムバスを介してのみメモリにアクセスする。**
  - **理由:** メモリとデバイスへのアクセスを一元化する「Transport Layer」の原則に従うため。これにより、ローダーは物理的なメモリレイアウトを意識せず、論理アドレス空間に対して操作できる。

- **原則: ローダーは、シンボル情報（ラベル）をロード結果の一部として提供する。**
  - **理由:** デバッガやUIが、ロードされたコードをより人間に理解しやすい形で表示できるようにするため。
-->

### 2. 主要なアーキテクチャ決定の記録 (Key Architectural Decisions)

*このセクションは、「なぜこの構造になったのか」を後から追えるように、重要な設計判断をログとして残します。*

<!--
- **Date:** 2026-02-05
- **Core Principle:** ローダーは、システムバスを介してのみメモリにアクセスする。
- **Decision:** `load()`メソッドは`Bus`インスタンスを受け取り、データの書き込みは`bus.write()`を介して行う。
- **Rationale:** ローダーがメモリの実装詳細に依存せず、バスの抽象化されたインターフェースを利用することで、異なるメモリ構成やデバイスを持つシステムにも柔軟に対応できるようにする。
- **Alternatives:**
  - ローダーが直接`RAM`オブジェクトや`bytearray`にアクセスする。→ メモリレイアウトが変更された場合にローダーの修正が必要となる。
- **Consequences:** `Bus`インスタンスがローダーに渡される必要がある。
-->

### 3. AIとの協調に関する指針 (AI Collaboration Policy)

*このセクションは、AIがどう振る舞うべきかの指針を記述します。*

- **未知の問題への対処:** この憲章に記載のない問題に直面した際、AIは`DESIGN_PHILOSOPHY.md`の根本思想に立ち返り、複数の選択肢とそれぞれのトレードオフを提示し、人間の判断を仰いでください。
- **戦略（憲章）と戦術（コメント）の連携:** この憲章（戦略）と、コード内に記述されるインテント・コメント（戦術）は、一貫性を保つべきです。AIは、コード生成時にインテント・コメントの草案を提案する責務を負います。

### 4. コンポーネント設計仕様 (Component Design Specifications)

*このセクションは、このマニフェストを元に、AIが人間と協調して機能的に同等なコードを再実装できるように、システムの主要コンポーネントの「設計仕様」を定義します。このセクションは、まず空のプレースホルダーとして生成され、人間とAIの対話を通じて合意形成をしながら埋めていくことを想定しています。単なる要約に留めず、第三者がマニフェストを読むだけで具体的な実装をイメージできるレベルまで、各コンポーネントの責務、APIのシグネチャ（引数、戻り値を含む）、データ構造、重要なアルゴリズム、状態遷移を詳細に記述することが極めて重要です。*

#### 4.1. SymbolMap (型エイリアス)
- **責務 (Responsibility):** シンボル名（文字列）とその対応するメモリアドレス（整数）をマッピングするための型を定義する。アセンブリソースのロード時に抽出されるシンボル情報を表現するために用いられる。
- **主要なデータ構造 (Key Data Structures):** `Dict[str, int]` の形式。

#### 4.2. IntelHexLoader (クラス)
- **責務 (Responsibility):** 標準的なIntel HEXファイルフォーマットを正確に解析し、その内容をシステムバス（`Bus`インスタンス）を通じてエミュレータのメモリ空間にロードする。ファイルの構文およびチェックサムの検証も行う。
- **提供するAPI (Public API):**
    - `load_intel_hex(self, file_path: str, bus: Bus) -> None`:
        - **責務:** 指定されたパスのIntel HEXファイルを読み込み、解析し、データを`bus`に書き込む。
        - **引数:**
            - `file_path` (str) - Intel HEXファイルへのパス。
            - `bus` (Bus) - データを書き込む対象のシステムバスインスタンス。
        - **前提条件:**
            - `file_path`は有効なIntel HEXファイルへのパスであること。
            - `bus`は有効な`Bus`オブジェクトであること。
        - **エラーハンドリング:**
            - ファイルフォーマットが不正、データ長が不一致、チェックサムが不一致の場合には`ValueError`を発生させる。
            - 未知のレコードタイプを検出した場合も`ValueError`を発生させる。
- **主要なデータ構造 (Key Data Structures):**
    - `current_extended_linear_address: int`: 拡張リニアアドレスレコード（タイプ0x04）によって設定される、現在のセグメントのベースアドレスを保持する。デフォルトは`0x0000`。
- **主要なアルゴリズム (Key Algorithms):**
    - **HEXレコード解析:** 各行を`:DD AAAA TT DD...CC`の形式で解析し、データ長、アドレスフィールド、レコードタイプ、データ部分、チェックサムを抽出する。
    - **チェックサム検証:** 各レコードについて、データ長、アドレス、レコードタイプ、データバイトの合計の2の補数を計算し、HEXファイル内のチェックサムと比較して整合性を検証する。
    - **アドレス計算:** ロードアドレスは`current_extended_linear_address`とレコード内のアドレスフィールドを組み合わせて決定される。
    - **バス書き込み:** 解析されたデータバイトは、計算されたロードアドレスに`bus.write()`メソッドを使用して書き込まれる。
- **状態とライフサイクル (State and Lifecycle):**
    - `IntelHexLoader`はステートレスなパーサーとして設計されており、`load_intel_hex`メソッドの呼び出しごとにファイルパスと`Bus`インスタンスを受け取る。
    - `current_extended_linear_address`はメソッド内部で管理される。

#### 4.3. AssemblyLoader (クラス)
- **責務 (Responsibility):** 簡易的なアセンブリソースコードファイルを解析し、ラベルなどのシンボル情報を抽出すると共に、対応するバイナリコードを生成してシステムバスにロードする。
- **提供するAPI (Public API):**
    - `load_assembly(self, file_path: str, bus: Bus) -> SymbolMap`:
        - **責務:** 指定されたアセンブリファイルを読み込み、解析し、シンボルマップを生成して、対応するバイナリをバスにロードする。
        - **現状:** 簡易実装済み。`ORG`, `DB`, ラベル（`label:`）、および一部の基本命令（`NOP`, `HALT`, `LD A,n`）をサポートする。
- **主要なアルゴリズム (Key Algorithms):**
    - **2パス・アセンブル (Simplified):**
        1.  **パス1 (解析):** ソースコードを行単位で読み込み、ラベルのメモリアドレスを確定させて `SymbolMap` を構築する。同時に、各行の命令サイズに基づいて `current_pc` を追跡する。
        2.  **パス2 (書き込み):** 解析された命令とデータ（`DB`）をバイナリバイトに変換し、`bus.write()` を使用して指定のアドレスに書き込む。
- **将来の検討事項 (Future Considerations):**
    - 全てのZ80命令セットへの対応。
    - 複数行にわたるマクロや、より複雑な数式表現のサポート。