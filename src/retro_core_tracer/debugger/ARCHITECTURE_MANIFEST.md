# ARCHITECTURE MANIFEST - Retro Core Tracer (Debugger Layer)

---
## Part 1: このマニフェストの取扱説明書 (Guide)

### 1. 目的 (Purpose): なぜこの憲章が存在するのか

このドキュメントは、プロジェクト「Retro Core Tracer」の特定モジュール「Debugger Layer」の「北極星」です。開発者とAIが共有する高レベルな目標と、決して譲れない技術的・哲学的制約を定義します。その目的は、場当たり的な実装を防ぎ、モジュールが長期にわたって技術的負債を抱えることなく、クリーンなアーキテクチャを維持し続けることにあります。

これにより、AIは単なるコード生成ツールを超え、アーキテクチャ全体と一貫した、より洞察に富んだ提案が可能な、真の協調開発パートナーとして機能します。

### 2. 憲章の書き方 (Guidelines)

*   **原則1: 具体的に記述する。**
    *   悪い例: 「高速であるべき」
    *   良い例: 「ブレークポイントの評価オーバーヘッドは、命令実行時間の5%未満に抑える」のように、検証可能な目標を設定します。

*   **原則2: 「なぜ」に焦点を当てる。**
    *   ルールだけではなく、その背景にあるトレードオフの判断を明記します。これが憲章の形骸化を防ぎ、将来の変更を助けます。
    *   例: 「我々は、デバッガの柔軟性よりも、CPUコアへの非侵襲性を優先する。なぜなら、コアの正確な動作再現が最重要だからだ。」

*   **原則3: 「禁止」ではなく「判断の背景」を記述する。**
    *   「禁止事項」や「守るべきルール」といった思考停止を招く言葉を避け、「我々はこういう判断をした」といった形で、判断に至った文脈や背景そのものを記述します。
    *   例: 「現時点では、デバッガはCPUコアの`step()`メソッドの戻り値である`Snapshot`オブジェクトのみを介してコアの状態を観測する、という判断をした。」

### 3. リスクと対策 (Risks and Mitigations)

*   **リスク:** ドキュメントが陳腐化し、現実のコードと乖離する。
    *   **対策:** アーキテクチャに影響を与えるコード変更（例: 新しいブレークポイントタイプの追加、デバッガAPIの責務変更）は、必ずこのマニフェストの更新とセットでレビューします。これは、`DESIGN_PHILOSOPHY.md`で定義された、AIと人間の双方が遵守すべき厳格なプロトコルです。

*   **リスク:** 全体原則と、特定のデバッグ要件（局所的な要求）が衝突する。
    *   **対策:** 原則としてこの憲章を優先します。ただし、局所的なコード内コメントで明確な理由（例: 「特定の命令フェッチアドレスに到達した際に、複数サイクル後に発生する現象を捕捉するため、特殊な遅延ブレークポイントを実装」）が示されている場合に限り、戦術的な逸脱を許容します。

---
## Part 2: マニフェスト本体 (Content)

### 1. 核となる原則 (Core Principles)

*このセクションは、モジュールの不変的なルールを「なぜ」の理由付けと共に定義します。*

<!--
- **原則: デバッガは、CPUコアの`step()`メソッドを呼び出すことによってのみ実行を制御する。**
  - **理由:** CPUコアとデバッガの間の明確な分離を維持し、CPUコアの設計がデバッガの都合によって汚染されないようにするため。

- **原則: デバッガは、`Snapshot`オブジェクトを介してのみCPUコアの状態を観測する。**
  - **理由:** CPUコアへの非侵襲性を確保し、デバッグ操作がエミュレーションの正確な動作に影響を与えないようにするため。また、不変な`Snapshot`はデバッグ情報の管理を簡素化する。
-->

### 2. 主要なアーキテクチャ決定の記録 (Key Architectural Decisions)

*このセクションは、「なぜこの構造になったのか」を後から追えるように、重要な設計判断をログとして残します。*

<!--
- **Date:** 2026-02-05
- **Core Principle:** デバッガは、`Snapshot`オブジェクトを介してのみCPUコアの状態を観測する。
- **Decision:** ブレークポイントの条件評価は、`step()`メソッドから返される`Snapshot`オブジェクトのデータに基づいて行う。
- **Rationale:** これにより、デバッガはCPUコアの内部状態に直接アクセスする必要がなくなり、疎結合が強化される。
- **Alternatives:**
  - デバッガがCPUコアのレジスタやメモリに直接アクセスするAPIを持つ。→ CPUコアとデバッガの結合度が高まり、コアの変更がデバッガに直接影響を与えるリスクがある。
- **Consequences:** `Snapshot`オブジェクトには、ブレークポイント評価に必要な全ての情報が含まれている必要がある。
-->

### 3. AIとの協調に関する指針 (AI Collaboration Policy)

*このセクションは、AIがどう振る舞うべきかの指針を記述します。*

- **未知の問題への対処:** この憲章に記載のない問題に直面した際、AIは`DESIGN_PHILOSOPHY.md`の根本思想に立ち返り、複数の選択肢とそれぞれのトレードオフを提示し、人間の判断を仰いでください。
- **戦略（憲章）と戦術（コメント）の連携:** この憲章（戦略）と、コード内に記述されるインテント・コメント（戦術）は、一貫性を保つべきです。AIは、コード生成時にインテント・コメントの草案を提案する責務を負います。

### 4. コンポーネント設計仕様 (Component Design Specifications)

*このセクションは、このマニフェストを元に、AIが人間と協調して機能的に同等なコードを再実装できるように、システムの主要コンポーネントの「設計仕様」を定義します。このセクションは、まず空のプレースホルダーとして生成され、人間とAIの対話を通じて合意形成をしながら埋めていくことを想定しています。単なる要約に留めず、第三者がマニフェストを読むだけで具体的な実装をイメージできるレベルまで、各コンポーネントの責務、APIのシグネチャ（引数、戻り値を含む）、データ構造、重要なアルゴリズム、状態遷移を詳細に記述することが極めて重要です。*

#### 4.1. BreakpointConditionType (Enum)
- **責務 (Responsibility):** ブレークポイントがトリガーされる様々な条件の種類を明確に定義する。
- **主要なデータ構造 (Key Data Structures):**
    - `PC_MATCH`: プログラムカウンタが特定のアドレスに一致する場合。
    - `MEMORY_READ`: 特定のメモリアドレスが読み込まれた場合。
    - `MEMORY_WRITE`: 特定のメモリアドレスに書き込まれた場合。
    - `REGISTER_VALUE`: 特定のレジスタが特定の値になった場合。
    - `REGISTER_CHANGE`: 特定のレジスタの値が変化した場合（実装はより複雑）。

#### 4.2. BreakpointCondition (データクラス)
- **責務 (Responsibility):** 単一のブレークポイントが発動するための具体的な条件を、そのタイプと関連する値と共に定義する。設定後は変更されない不変（immutable）な条件を表現する。
- **主要なデータ構造 (Key Data Structures):**
    - `condition_type: BreakpointConditionType`: ブレークポイントの条件タイプ。
    - `value: Optional[int] = None`: `PC_MATCH`や`REGISTER_VALUE`の場合に比較する値。
    - `address: Optional[int] = None`: `MEMORY_READ`や`MEMORY_WRITE`の場合に監視するメモリアドレス。
    - `register_name: Optional[str] = None`: `REGISTER_VALUE`や`REGISTER_CHANGE`の場合に監視するレジスタの名前（文字列）。
- **状態とライフサイクル (State and Lifecycle):** `frozen=True`が設定されており、インスタンス生成後は完全に不変である。これにより、条件の一貫性が保証される。

#### 4.3. Debugger (主要コンポーネント)
- **責務 (Responsibility):**
    - `AbstractCpu`の実行フローを制御（一時停止、継続、ステップ実行）。
    - ユーザー定義のブレークポイント条件を管理し、条件が満たされた場合にCPUの実行を中断する。
    - CPUコアの内部状態に直接干渉することなく、`Snapshot`オブジェクトを介してCPUとバスの状態を観測する。
- **提供するAPI (Public API):**
    - `__init__(self, cpu: AbstractCpu)`:
        - **責務:** `Debugger`インスタンスを初期化し、デバッグ対象となる`AbstractCpu`インスタンスへの参照を保持する。
        - **引数:** `cpu` (`AbstractCpu`) - デバッグ対象のCPUインスタンス。
    - `add_breakpoint(self, condition: BreakpointCondition) -> None`:
        - **責務:** 新しいブレークポイント条件をデバッガのリストに追加する。重複する条件は追加しない。
        - **引数:** `condition` (`BreakpointCondition`) - 追加するブレークポイント条件。
    - `remove_breakpoint(self, condition: BreakpointCondition) -> None`:
        - **責務:** 既存のブレークポイント条件をデバッガのリストから削除する。
        - **引数:** `condition` (`BreakpointCondition`) - 削除するブレークポイント条件。
    - `get_breakpoints(self) -> List[BreakpointCondition]`:
        - **責務:** 現在設定されている全てのブレークポイントのリスト（コピー）を返す。
    - `step_instruction(self) -> Snapshot`:
        - **責務:** `AbstractCpu`の`step()`メソッドを1回呼び出し、CPUを1命令分実行する。実行結果として`Snapshot`オブジェクトを返し、`REGISTER_CHANGE`ブレークポイントのために前回のCPU状態を更新する。
        - **戻り値:** `Snapshot` - 命令実行後のCPUとバスの状態。
    - `get_last_snapshot(self) -> Optional[Snapshot]`:
        - **責務:** 最後に実行されたステップ（命令）の結果生成された`Snapshot`オブジェクトを返す。まだ実行されていない場合は`None`を返す。
    - `run(self) -> None`:
        - **責務:** CPUの実行を連続的に継続する。ブレークポイントにヒットするか、`stop()`メソッドが呼び出されるまでループを続ける。
        - **実行制御フロー:**
            1. `PC_MATCH`タイプのブレークポイントを命令実行前にチェックする。
            2. `step_instruction()`を呼び出し、命令を実行し`Snapshot`を取得する。
            3. `_check_other_breakpoints()`を呼び出し、`PC_MATCH`以外のブレークポイント（メモリ読み書き、レジスタ値）を`Snapshot`に基づいてチェックする。
            4. いずれかのブレークポイントにヒットした場合、連続実行を停止する。
    - `stop(self) -> None`:
        - **責務:** `run()`メソッドで実行中の連続実行ループを中断するようシグナルを送る。
- **主要なデータ構造 (Key Data Structures):**
    - `_cpu: AbstractCpu`: デバッグ対象の`AbstractCpu`インスタンスへの参照。
    - `_breakpoints: List[BreakpointCondition]`: 現在アクティブな`BreakpointCondition`オブジェクトのリスト。
    - `_running: bool`: デバッガが連続実行中であるかどうかを示すフラグ。
    - `_previous_state: Optional[CpuState]`: `REGISTER_CHANGE`ブレークポイントの評価のために、直前のCPUの状態を保持する（現在の実装ではコメントアウトされ、利用されていない）。
- **重要なアルゴリズム (Key Algorithms):**
    - **ブレークポイント評価:**
        - `PC_MATCH`は、`run()`ループ内で`AbstractCpu.get_state().pc`とブレークポイント条件の`value`を比較することで、命令実行*前*にチェックされる。
        - `MEMORY_READ`, `MEMORY_WRITE`は、`_check_other_breakpoints()`内で`Snapshot.bus_activity`を走査し、`BusAccess`のアドレスとタイプをブレークポイント条件と比較することで、命令実行*後*にチェックされる。
        - `REGISTER_VALUE`は、`_check_other_breakpoints()`内で`Snapshot.state`の指定されたレジスタ属性とブレークポイント条件の`value`を比較することで、命令実行*後*にチェックされる。
    - **実行制御ループ:** `run()`メソッド内の`while self._running`ループが、ブレークポイントのチェックと`step_instruction()`の呼び出しを繰り返し、CPUの実行フローを管理する。
- **状態とライフサイクル (State and Lifecycle):**
    - `Debugger`インスタンスは、`AbstractCpu`インスタンスへの参照を保持し、アプリケーションのライフサイクルを通じてデバッグセッションを管理する。
    - `_breakpoints`リストは`add_breakpoint`と`remove_breakpoint`により動的に変化する。
    - `_running`フラグは`run`と`stop`メソッドにより制御される。