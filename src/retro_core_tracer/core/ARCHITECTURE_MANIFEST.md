# ARCHITECTURE MANIFEST - Retro Core Tracer (Core Layer)

---
## Part 1: このマニフェストの取扱説明書 (Guide)

### 1. 目的 (Purpose): なぜこの憲章が存在するのか

このドキュメントは、プロジェクト「Retro Core Tracer」の特定モジュール「Core Layer」の「北極星」です。開発者とAIが共有する高レベルな目標と、決して譲れない技術的・哲学的制約を定義します。その目的は、場当たり的な実装を防ぎ、モジュールが長期にわたって技術的負債を抱えることなく、クリーンなアーキテクチャを維持し続けることにあります。

これにより、AIは単なるコード生成ツールを超え、アーキテクチャ全体と一貫した、より洞察に富んだ提案が可能な、真の協調開発パートナーとして機能します。

### 2. 憲章の書き方 (Guidelines)

*   **原則1: 具体的に記述する。**
    *   悪い例: 「高速であるべき」
    *   良い例: 「1命令あたりの実行オーバーヘッドは、ネイティブ実行時間の500%未満に抑える」のように、検証可能な目標を設定します。

*   **原則2: 「なぜ」に焦点を当てる。**
    *   ルールだけではなく、その背景にあるトレードオフの判断を明記します。これが憲章の形骸化を防ぎ、将来の変更を助けます。
    *   例: 「我々は、UIの応答性よりもエミュレーションの正確性を優先する。なぜなら、このプロジェクトの第一目的は教育的な透明性の確保だからだ。」

*   **原則3: 「禁止」ではなく「判断の背景」を記述する。**
    *   「禁止事項」や「守るべきルール」といった思考停止を招く言葉を避け、「我々はこういう判断をした」といった形で、判断に至った文脈や背景そのものを記述します。
    *   例: 「現時点では、コアロジックとUIの結合を避けるため、両者はSnapshotオブジェクトを通してのみ通信する、という判断をした。」

### 3. リスクと対策 (Risks and Mitigations)

*   **リスク:** ドキュメントが陳腐化し、現実のコードと乖離する。
    *   **対策:** アーキテクチャに影響を与えるコード変更（例: 新コンポーネントの追加、既存APIの責務変更）は、必ずこのマニフェストの更新とセットでレビューします。これは、`DESIGN_PHILOSOPHY.md`で定義された、AIと人間の双方が遵守すべき厳格なプロトコルです。

*   **リスク:** 全体原則と、特定のCPUアーキテクチャ（局所的な要求）が衝突する。
    *   **対策:** 原則としてこの憲章を優先します。ただし、局所的なコード内コメントで明確な理由（例: 「6809の特殊なアドレッシングモードのため、標準バスアクセスを逸脱」）が示されている場合に限り、戦術的な逸脱を許容します。

---
## Part 2: マニフェスト本体 (Content)

### 1. 核となる原則 (Core Principles)

*このセクションは、モジュールの不変的なルールを「なぜ」の理由付けと共に定義します。*

<!--
- **原則: CPUコアは、特定のCPUアーキテクチャの実装詳細に依存しない。**
  - **理由:** 複数のCPUアーキテクチャを単一の抽象モデルで扱うというプロジェクト全体の原則を、Core Layerで維持するため。命令のデコードや実行はInstruction Layerの責務とする。

- **原則: CPUの状態は、不変なStateオブジェクトとして管理される。**
  - **理由:** 時間軸を考慮した設計検証のため、CPU状態の変更を追跡しやすくし、デバッグやUndo/Redo機能の実装を容易にするため。
-->

### 2. 主要なアーキテクチャ決定の記録 (Key Architectural Decisions)

*このセクションは、「なぜこの構造になったのか」を後から追えるように、重要な設計判断をログとして残します。*

<!--
- **Date:** 2026-02-05
- **Core Principle:** CPUコアは、特定のCPUアーキテクチャの実装詳細に依存しない。
- **Decision:** 命令サイクル（フェッチ→デコード→実行）の制御ロジックをCore Layerに置き、具体的な命令の解釈と実行は、アーキテクチャ固有のInstruction Layerに委譲するインターフェースを定義する。
- **Rationale:** Core Layerをアーキテクチャに依存しない汎用的な実行エンジンとして機能させることで、異なるCPUエミュレーションへの拡張性を高める。
- **Alternatives:**
  - 全ての命令実行ロジックをCore Layerに直接記述する。→ CPUアーキテクチャが増えるたびにCore Layerが肥大化し、保守性が低下する。
- **Consequences:** Core LayerとInstruction Layer間のインターフェース設計が重要になる。
-->

### 3. AIとの協調に関する指針 (AI Collaboration Policy)

*このセクションは、AIがどう振る舞うべきかの指針を記述します。*

- **未知の問題への対処:** この憲章に記載のない問題に直面した際、AIは`DESIGN_PHILOSOPHY.md`の根本思想に立ち返り、複数の選択肢とそれぞれのトレードオフを提示し、人間の判断を仰いでください。
- **戦略（憲章）と戦術（コメント）の連携:** この憲章（戦略）と、コード内に記述されるインテント・コメント（戦術）は、一貫性を保つべきです。AIは、コード生成時にインテント・コメントの草案を提案する責務を負います。

### 4. コンポーネント設計仕様 (Component Design Specifications)

*このセクションは、このマニフェストを元に、AIが人間と協調して機能的に同等なコードを再実装できるように、システムの主要コンポーネントの「設計仕様」を定義します。このセクションは、まず空のプレースホルダーとして生成され、人間とAIの対話を通じて合意形成をしながら埋めていくことを想定しています。単なる要約に留めず、第三者がマニフェストを読むだけで具体的な実装をイメージできるレベルまで、各コンポーネントの責務、APIのシグネチャ（引数、戻り値を含む）、データ構造、重要なアルゴリズム、状態遷移を詳細に記述することが極めて重要です。*

#### 4.1. CpuState (データクラス)
- **責務 (Responsibility):** CPUの基本的なレジスタ状態（プログラムカウンタ、スタックポインタなど）を保持する。これは抽象的な基底状態であり、具体的なCPUアーキテクチャに応じて拡張されることを意図している。
- **主要なデータ構造 (Key Data Structures):**
    - `pc: int`: プログラムカウンタ。次に実行される命令のアドレスを指す。初期値は`0x0000`。
    - `sp: int`: スタックポインタ。スタックの現在位置を指す。初期値は`0x0000`。
    - **その他:** 具体的なレジスタ（A, B, C, D, E, H, L, Fなど）は、特定のCPUアーキテクチャの`CpuState`サブクラスで定義される。
- **状態とライフサイクル (State and Lifecycle):**
    - `CpuState`のインスタンスはCPUの可変状態を保持する。
    - `reset()`メソッドにより初期状態に戻される。

#### 4.2. Operation (データクラス)
- **責務 (Responsibility):** CPUによって実行された単一の命令に関する詳細な情報を不変の形式で記録する。デバッガやUIでの表示、命令セットの分析に用いられる。
- **主要なデータ構造 (Key Data Structures):**
    - `opcode_hex: str`: 実行された命令のオペコードを16進数文字列で表現（例: "C3"）。
    - `mnemonic: str`: 命令のニーモニック（例: "JP"）。
    - `operands: List[str]`: 命令のオペランドを文字列リストで表現（例: ["$1234"]）。
    - `operand_bytes: List[int]`: 生のオペランドバイトのリスト。
    - `cycle_count: int`: この命令の実行に必要なクロックサイクル数。
    - `length: int`: 命令のバイト長。
- **状態とライフサイクル (State and Lifecycle):** インスタンス生成後に状態は変更されない不変（immutable）なデータ構造である。

#### 4.3. Metadata (データクラス)
- **責務 (Responsibility):** CPUの実行に関する補助的な情報（累計サイクル数やシンボル情報など）を不変の形式で記録する。
- **主要なデータ構造 (Key Data Structures):**
    - `cycle_count: int`: 累計クロックサイクル数。
    - `symbol_info: Optional[str]`: 現在のPCに対応するソースコードのシンボル情報やラベル（例: "main_loop: JP $1234"）。
- **状態とライフサイクル (State and Lifecycle):** インスタンス生成後に状態は変更されない不変（immutable）なデータ構造である。

#### 4.4. Snapshot (データクラス)
- **責務 (Responsibility):** ある一時点におけるCPUの完全なレジスタ状態、実行された命令の詳細、バスアクティビティ、および実行メタデータを一つにまとめた不変のデータ構造として提供する。これはUIへの情報提供、デバッグ時の状態記録、タイムトラベルデバッグの基礎となる。
- **主要なデータ構造 (Key Data Structures):**
    - `state: CpuState`: 命令実行後のCPUレジスタ状態。
    - `operation: Operation`: 実行された命令の詳細。
    - `metadata: Metadata`: 実行に関するメタデータ。
    - `bus_activity: List[BusAccess]`: 命令実行中に発生した全てのバスアクセス操作のリスト。
- **状態とライフサイクル (State and Lifecycle):** `frozen=True`が設定されており、インスタンス生成後は完全に不変である。リストフィールドには`default_factory`が使用され、ミュータブルなデフォルト引数問題を回避している。

#### 4.5. AbstractCpu (抽象基底クラス)
- **責務 (Responsibility):**
    - 全てのCPUエミュレーションの共通基盤を提供する。
    - `Bus`とのインターフェース、基本的な`CpuState`の管理を行う。
    - 命令サイクル（フェッチ→デコード→実行）の制御フローを抽象化する。
    - 具体的な命令の振る舞いや、CPU固有の状態管理は、派生クラス（Instruction Layer）に委譲する。
- **提供するAPI (Public API):**
    - `__init__(self, bus: Bus)`:
        - **責務:** `AbstractCpu`インスタンスを初期化し、システムバスへの参照と初期`CpuState`を設定する。
        - **引数:** `bus` (Bus) - システムの共通バスインスタンス。
    - `reset(self) -> None`:
        - **責務:** CPUの状態を初期化時の状態にリセットする。
        - **設計上の決定:** `_create_initial_state()`を再呼び出しすることで、初期化ロジックの一貫性を保証する。
    - `get_state(self) -> CpuState`:
        - **責務:** 現在のCPUのレジスタ状態を返す。
        - **設計上の決定:** 内部の`_state`オブジェクトの直接操作を避け、メソッド経由でのアクセスを強制することで状態の整合性を高める。
    - `step(self) -> Snapshot`:
        - **責務:** CPUを1命令サイクル進め、その結果（実行後のCPU状態、命令、バスアクティビティ、メタデータ）を`Snapshot`オブジェクトとして返す。
        - **処理フロー:** 内部で`_fetch()` -> `_decode()` -> `_execute()`をオーケストレートする。
        - **将来の検討事項:** 現在のところ`bus_activity`と`metadata`の一部はダミー値であり、バスアクティビティの正確な記録とサイクルカウント/シンボル情報の取得が今後の課題である。
- **抽象メソッド (派生クラスでの実装が必須):**
    - `_create_initial_state(self) -> CpuState`:
        - **責務:** CPUの初期状態を生成して返す。CPUアーキテクチャ固有の`CpuState`サブクラスを返すことができる。
    - `_fetch(self) -> int`:
        - **責務:** 現在の`pc`からメモリの次の命令（オペコード）をバス経由でフェッチし、PCを更新する。
    - `_decode(self, opcode: int) -> Operation`:
        - **責務:** フェッチされたオペコードを解析し、その命令の詳細（ニーモニック、オペランドなど）を`Operation`オブジェクトとして返す。
    - `_execute(self, operation: Operation) -> None`:
        - **責務:** デコードされた命令を実行し、レジスタやフラグなどのCPUの状態を更新する。
- **主要なデータ構造 (Key Data Structures):**
    - `_bus: Bus`: システムの共通バスインスタンスへの参照。
    - `_state: CpuState`: 現在のCPUのレジスタ状態を保持する`CpuState`インスタンス。
- **重要なアルゴリズム (Key Algorithms):**
    - **命令サイクル制御:** `step()`メソッドがフェッチ、デコード、実行のシーケンスを管理し、CPUの基本的な動作サイクルを駆動する。
- **状態とライフサイクル (State and Lifecycle):**
    - `AbstractCpu`インスタンスは、`bus`と`_state`への参照を保持し、アプリケーションのライフサイクルを通じて命令実行を制御する。

#### 4.6. アーキテクチャ上の検討事項 (Architectural Considerations)
- **BusAccessTypeとBusAccessの定義重複:**
    - 現在、`src/retro_core_tracer/transport/bus.py`と`src/retro_core_tracer/core/snapshot.py`の両方で`BusAccessType`と`BusAccess`が独立して定義されている。
    - **影響:** コードの重複、定義の不整合リスク、および`core/snapshot.py`が`transport/bus.py`を直接インポートすると循環参照を引き起こす可能性がある（`transport.bus`は`core.snapshot`をインポートしない）。
    - **解決案:** これらの共通データ構造を`src/retro_core_tracer/common/`のような共有モジュールに移動するか、`snapshot.py`が`transport.bus`からインポートするようにリファクタリングを検討する。後者の場合、`snapshot`の定義は`transport`に依存することになるが、バスアクティビティを記録する`BusAccess`は概念的に`transport`層に属するため、より自然である。現時点では、`AbstractCpu`が`Snapshot`を使用するため、`core/snapshot.py`が`transport.bus`をインポートする形が望ましいが、循環参照を防ぐためには定義の移動が最も健全な解決策となる。