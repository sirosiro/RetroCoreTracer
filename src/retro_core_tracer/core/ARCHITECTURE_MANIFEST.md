# ARCHITECTURE MANIFEST - Retro Core Tracer (Core Layer)

---
## Part 1: このマニフェストの取扱説明書 (Guide)

### 1. 目的 (Purpose): なぜこの憲章が存在するのか

このドキュメントは、プロジェクト「Retro Core Tracer」の特定モジュール「Core Layer」の「北極星」です。開発者とAIが共有する高レベルな目標と、決して譲れない技術的・哲学的制約を定義します。その目的は、場当たり的な実装を防ぎ、モジュールが長期にわたって技術的負債を抱えることなく、クリーンなアーキテクチャを維持し続けることにあります。

これにより、AIは単なるコード生成ツールを超え、アーキテクチャ全体と一貫した、より洞察に富んだ提案が可能な、真の協調開発パートナーとして機能します。

### 2. 憲章の書き方 (Guidelines)

*   **原則1: 具体的に記述する。**
    *   悪い例: 「高速であるべき」
    *   良い例: 「1命令あたりの実行オーバーヘッドは、ネイティブ実行時間の500%未満に抑える」のように、検証可能な目標を設定します。

*   **原則2: 「なぜ」に焦点を当てる。**
    *   ルールだけではなく、その背景にあるトレードオフの判断を明記します。これが憲章の形骸化を防ぎ、将来の変更を助けます。
    *   例: 「我々は、UIの応答性よりもエミュレーションの正確性を優先する。なぜなら、このプロジェクトの第一目的は教育的な透明性の確保だからだ。」

*   **原則3: 「禁止」ではなく「判断の背景」を記述する。**
    *   「禁止事項」や「守るべきルール」といった思考停止を招く言葉を避け、「我々はこういう判断をした」といった形で、判断に至った文脈や背景そのものを記述します。
    *   例: 「現時点では、コアロジックとUIの結合を避けるため、両者はSnapshotオブジェクトを通してのみ通信する、という判断をした。」

### 3. リスクと対策 (Risks and Mitigations)

*   **リスク:** ドキュメントが陳腐化し、現実のコードと乖離する。
    *   **対策:** アーキテクチャに影響を与えるコード変更（例: 新コンポーネントの追加、既存APIの責務変更）は、必ずこのマニフェストの更新とセットでレビューします。これは、`DESIGN_PHILOSOPHY.md`で定義された、AIと人間の双方が遵守すべき厳格なプロトコルです。

*   **リスク:** 全体原則と、特定のCPUアーキテクチャ（局所的な要求）が衝突する。
    *   **対策:** 原則としてこの憲章を優先します。ただし、局所的なコード内コメントで明確な理由（例: 「6809の特殊なアドレッシングモードのため、標準バスアクセスを逸脱」）が示されている場合に限り、戦術的な逸脱を許容します。

---
## Part 2: マニフェスト本体 (Content)

### 1. 核となる原則 (Core Principles)

*このセクションは、モジュールの不変的なルールを「なぜ」の理由付けと共に定義します。*

<!--
- **原則: CPUコアは、特定のCPUアーキテクチャの実装詳細に依存しない。**
  - **理由:** 複数のCPUアーキテクチャを単一の抽象モデルで扱うというプロジェクト全体の原則を、Core Layerで維持するため。命令のデコードや実行はInstruction Layerの責務とする。

- **原則: CPUの状態は、不変なStateオブジェクトとして管理される。**
  - **理由:** 時間軸を考慮した設計検証のため、CPU状態の変更を追跡しやすくし、デバッグやUndo/Redo機能の実装を容易にするため。
-->

### 2. 主要なアーキテクチャ決定の記録 (Key Architectural Decisions)

*このセクションは、「なぜこの構造になったのか」を後から追えるように、重要な設計判断をログとして残します。*

<!--
- **Date:** 2026-02-05
- **Core Principle:** CPUコアは、特定のCPUアーキテクチャの実装詳細に依存しない。
- **Decision:** 命令サイクル（フェッチ→デコード→実行）の制御ロジックをCore Layerに置き、具体的な命令の解釈と実行は、アーキテクチャ固有のInstruction Layerに委譲するインターフェースを定義する。
- **Rationale:** Core Layerをアーキテクチャに依存しない汎用的な実行エンジンとして機能させることで、異なるCPUエミュレーションへの拡張性を高める。
- **Alternatives:**
  - 全ての命令実行ロジックをCore Layerに直接記述する。→ CPUアーキテクチャが増えるたびにCore Layerが肥大化し、保守性が低下する。
- **Consequences:** Core LayerとInstruction Layer間のインターフェース設計が重要になる。
-->

- **Date:** 2026-02-12
- **Core Principle:** コアロジックは、特定のUI技術から完全に分離される。
- **Decision:** `AbstractCpu` に `has_io_port` プロパティを追加し、UIがアーキテクチャ名（文字列）に依存せずにI/O表示を切り替えられるようにする。
- **Rationale:** `CoreCanvas` 等のUIコンポーネントが "Z80" という具体的な文字列を知っている状態（密結合）を解消するため。機能ベースのインターフェースにより、将来のアーキテクチャ追加にも柔軟に対応できる。

### 3. AIとの協調に関する指針 (AI Collaboration Policy)

*このセクションは、AIがどう振る舞うべきかの指針を記述します。*

- **未知の問題への対処:** この憲章に記載のない問題に直面した際、AIは`DESIGN_PHILOSOPHY.md`の根本思想に立ち返り、複数の選択肢とそれぞれのトレードオフを提示し、人間の判断を仰いでください。
- **戦略（憲章）と戦術（コメント）の連携:** この憲章（戦略）と、コード内に記述されるインテント・コメント（戦術）は、一貫性を保つべきです。AIは、コード生成時にインテント・コメントの草案を提案する責務を負います。

### 4. コンポーネント設計仕様 (Component Design Specifications)

*このセクションは、このマニフェストを元に、AIが人間と協調して機能的に同等なコードを再実装できるように、システムの主要コンポーネントの「設計仕様」を定義します。このセクションは、まず空のプレースホルダーとして生成され、人間とAIの対話を通じて合意形成をしながら埋めていくことを想定しています。単なる要約に留めず、第三者がマニフェストを読むだけで具体的な実装をイメージできるレベルまで、各コンポーネントの責務、APIのシグネチャ（引数、戻り値を含む）、データ構造、重要なアルゴリズム、状態遷移を詳細に記述することが極めて重要です。*

#### 4.1. CpuState (データクラス)
- **責務 (Responsibility):** CPUの基本的なレジスタ状態（プログラムカウンタ、スタックポインタなど）を保持する。これは抽象的な基底状態であり、具体的なCPUアーキテクチャに応じて拡張されることを意図している。
- **主要なデータ構造 (Key Data Structures):**
    - `pc: int`: プログラムカウンタ。次に実行される命令のアドレスを指す。初期値は`0x0000`。
    - `sp: int`: スタックポインタ。スタックの現在位置を指す。初期値は`0x0000`。
    - **その他:** 具体的なレジスタ（A, B, C, D, E, H, L, Fなど）は、特定のCPUアーキテクチャの`CpuState`サブクラスで定義される。
- **状態とライフサイクル (State and Lifecycle):**
    - `CpuState`のインスタンスはCPUの可変状態を保持する。
    - `reset()`メソッドにより初期状態に戻される。

#### 4.2. Operation (データクラス)
- **責務 (Responsibility):** CPUによって実行された単一の命令に関する詳細な情報を不変の形式で記録する。デバッガやUIでの表示、命令セットの分析に用いられる。
- **主要なデータ構造 (Key Data Structures):**
    - `opcode_hex: str`: 実行された命令のオペコードを16進数文字列で表現（例: "C3"）。
    - `mnemonic: str`: 命令のニーモニック（例: "JP"）。
    - `operands: List[str]`: 命令のオペランドを文字列リストで表現（例: ["$1234"]）。
    - `operand_bytes: List[int]`: 生のオペランドバイトのリスト。
    - `cycle_count: int`: この命令の実行に必要なクロックサイクル数。
    - `length: int`: 命令のバイト長。
- **状態とライフサイクル (State and Lifecycle):** インスタンス生成後に状態は変更されない不変（immutable）なデータ構造である。

#### 4.3. Metadata (データクラス)
- **責務 (Responsibility):** CPUの実行に関する補助的な情報（累計サイクル数やシンボル情報など）を不変の形式で記録する。
- **主要なデータ構造 (Key Data Structures):**
    - `cycle_count: int`: 累計クロックサイクル数。
    - `symbol_info: Optional[str]`: 現在のPCに対応するソースコードのシンボル情報やラベル（例: "main_loop: JP $1234"）。
- **状態とライフサイクル (State and Lifecycle):** インスタンス生成後に状態は変更されない不変（immutable）なデータ構造である。

#### 4.4. Snapshot (データクラス)
- **責務 (Responsibility):** ある一時点におけるCPUの完全なレジスタ状態、実行された命令の詳細、バスアクティビティ、および実行メタデータを一つにまとめた不変のデータ構造として提供する。これはUIへの情報提供、デバッグ時の状態記録、タイムトラベルデバッグの基礎となる。
- **主要なデータ構造 (Key Data Structures):**
    - `state: CpuState`: 命令実行後のCPUレジスタ状態。
    - `operation: Operation`: 実行された命令の詳細。
    - `metadata: Metadata`: 実行に関するメタデータ。
    - `bus_activity: List[BusAccess]`: 命令実行中に発生した全てのバスアクセス操作のリスト。
- **状態とライフサイクル (State and Lifecycle):** `frozen=True`が設定されており、インスタンス生成後は完全に不変である。リストフィールドには`default_factory`が使用され、ミュータブルなデフォルト引数問題を回避している。

#### 4.5. AbstractCpu (抽象基底クラス)
- **責務 (Responsibility):**
    - 全てのCPUエミュレーションの共通基盤を提供する。
    - `Bus`とのインターフェース、基本的な`CpuState`の管理を行う。
    - 命令サイクル（フェッチ→デコード→実行）の制御フローを抽象化する。
    - **シンボル情報の管理:** 外部（ローダー等）から提供されたシンボル情報を保持し、実行時の可視化に利用する。
    - 具体的な命令の振る舞いや、CPU固有の状態管理は、派生クラス（Instruction Layer）に委譲する。
- **提供するAPI (Public API):**
    - `__init__(self, bus: Bus)`:
        - **責務:** `AbstractCpu`インスタンスを初期化し、システムバスへの参照と初期`CpuState`を設定する。
        - **引数:** `bus` (Bus) - システムの共通バスインスタンス。
    - `has_io_port(self) -> bool`:
        - **責務:** このCPUが独立したI/O空間（ポート入出力）をサポートしているか返す。
        - **用途:** UIがI/Oマップやバスを表示すべきかを判断するために使用。
    - `set_symbol_map(self, symbol_map: Dict[str, int]) -> None`:
        - **責務:** シンボルマップを設定し、アドレスからの逆引きマップを内部的に構築する。
    - `reset(self) -> None`:
        - **責務:** CPUの状態を初期化時の状態にリセットする。
        - **設計上の決定:** `_create_initial_state()`を再呼び出しすることで、初期化ロジックの一貫性を保証する。
    - `get_state(self) -> CpuState`:
        - **責務:** 現在のCPUのレジスタ状態を返す。
        - **設計上の決定:** 内部の`_state`オブジェクトの直接操作を避け、メソッド経由でのアクセスを強制することで状態の整合性を高める。
    - `step(self) -> Snapshot`:
        - **責務:** CPUを1命令サイクル進め、その結果（実行後のCPU状態、命令、バスアクティビティ、メタデータ）を完全な`Snapshot`オブジェクトとして返す。
        - **処理フロー:**
            1. `_bus.get_and_clear_activity_log()` を呼び出し、前サイクルまでの残存ログを破棄（または警告）する。
            2. `_fetch()` を実行。
            3. `_decode()` を実行。
            4. `_execute()` を実行。
            5. `_bus.get_and_clear_activity_log()` を再度呼び出し、この命令サイクル中（フェッチ〜実行）に発生した全てのバスアクセスを収集する。
            6. 命令固有のサイクル数を計算し、累積サイクル数(`metadata.cycle_count`)を更新する。
            7. 収集したバスアクティビティと更新されたメタデータを含む `Snapshot` を生成して返す。
        - **保証事項:** 返される `Snapshot.bus_activity` には、その命令のフェッチから実行完了までに発生した全てのメモリアクセスが、発生順に記録されていなければならない。
- **抽象メソッド (派生クラスでの実装が必須):**
    - `_create_initial_state(self) -> CpuState`:
        - **責務:** CPUの初期状態を生成して返す。CPUアーキテクチャ固有の`CpuState`サブクラスを返すことができる。
    - `_fetch(self) -> int`:
        - **責務:** 現在の`pc`からメモリの次の命令（オペコード）をバス経由でフェッチし、PCを更新する。
    - `_decode(self, opcode: int) -> Operation`:
        - **責務:** フェッチされたオペコードを解析し、その命令の詳細（ニーモニック、オペランドなど）を`Operation`オブジェクトとして返す。
    - `_execute(self, operation: Operation) -> None`:
        - **責務:** デコードされた命令を実行し、レジスタやフラグなどのCPUの状態を更新する。
    - `get_register_map(self) -> Dict[str, int]`:
        - **責務:** 現在のレジスタ値を辞書形式で返す。UI（RegisterView）がCPUの内部構造を知らなくても値を表示できるようにするために使用される。
        - **戻り値:** `Key`: レジスタ名（例: "A", "PC"）, `Value`: 現在の値。
    - `get_register_layout(self) -> List[RegisterLayoutInfo]`:
        - **責務:** レジスタをUI上でどのように配置・グループ化すべきかの定義を返す。
        - **戻り値:** レジスタレイアウト情報のリスト。
    - `get_flag_state(self) -> Dict[str, bool]`:
        - **責務:** 現在のフラグ（ステータスレジスタ）の各ビットの状態を辞書形式で返す。
        - **戻り値:** `Key`: フラグ名（例: "Z", "C"）, `Value`: ON/OFF状態。
    - `disassemble(self, start_addr: int, length: int) -> List[Tuple[int, str, str]]`:
        - **責務:** 指定されたメモリ範囲を逆アセンブルし、アドレス、バイト列、ニーモニックのタプルリストを返す。
        - **引数:**
            - `start_addr`: 開始アドレス。
            - `length`: バイト長。
        - **戻り値:** `(address, hex_bytes, mnemonic)` のリスト。
- **主要なデータ構造 (Key Data Structures):**
    - `_bus: Bus`: システムの共通バスインスタンスへの参照。
    - `_state: CpuState`: 現在のCPUのレジスタ状態を保持する`CpuState`インスタンス。
    - `_symbol_map: Dict[str, int]`: ロードされたシンボル（名前からアドレス）。
    - `_reverse_symbol_map: Dict[int, str]`: アドレスからシンボル名への逆引きマップ。
- **重要なアルゴリズム (Key Algorithms):**
    - **命令サイクル制御:** `step()`メソッドがフェッチ、デコード、実行のシーケンスを管理し、CPUの基本的な動作サイクルを駆動する。
    - **実行時のシンボル解決:** `step()`メソッド内で実行前のPCを元に `_reverse_symbol_map` を引き、ラベル情報を `Snapshot.metadata.symbol_info` に自動的に付与する。
- **状態とライフサイクル (State and Lifecycle):**
    - `AbstractCpu`インスタンスは、`bus`と`_state`への参照を保持し、アプリケーションのライフサイクルを通じて命令実行を制御する。

#### 4.6. アーキテクチャ上の検討事項 (Architectural Considerations)
- **BusAccessTypeとBusAccessの定義場所:**
    - **課題:** `Snapshot`はバスアクティビティを記録するために`BusAccess`型を必要とする。
    - **決定:** `BusAccess`および`BusAccessType`は`src/retro_core_tracer/transport/bus.py`で定義し、`src/retro_core_tracer/core/snapshot.py`はこれをインポートして使用する。
    - **理由:** バスアクセス情報の定義はTransport層の責務であり、Core層のSnapshotはそれを「利用」する立場であるため。これにより定義の重複を排除し、単一の真実（Single Source of Truth）を維持する。