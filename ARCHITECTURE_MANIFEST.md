# ARCHITECTURE MANIFEST - Retro Core Tracer

---
## Part 1: このマニフェストの取扱説明書 (Guide)

### 1. 目的 (Purpose): なぜこの憲章が存在するのか

このドキュメントは、プロジェクト「Retro Core Tracer」の「北極星」です。開発者とAIが共有する高レベルな目標と、決して譲れない技術的・哲学的制約を定義します。その目的は、場当たり的な実装を防ぎ、プロジェクトが長期にわたって技術的負債を抱えることなく、クリーンなアーキテクチャを維持し続けることにあります。

これにより、AIは単なるコード生成ツールを超え、アーキテクチャ全体と一貫した、より洞察に富んだ提案が可能な、真の協調開発パートナーとして機能します。

### 2. 憲章の書き方 (Guidelines)

*   **原則1: 具体的に記述する。**
    *   悪い例: 「高速であるべき」
    *   良い例: 「Z80の1命令あたりの実行オーバーヘッドは、ネイティブ実行時間の500%未満に抑える」のように、検証可能な目標を設定します。

*   **原則2: 「なぜ」に焦点を当てる。**
    *   ルールだけではなく、その背景にあるトレードオフの判断を明記します。これが憲章の形骸化を防ぎ、将来の変更を助けます。
    *   例: 「我々は、UIの応答性よりもエミュレーションの正確性を優先する。なぜなら、このプロジェクトの第一目的は教育的な透明性の確保だからだ。」

*   **原則3: 「禁止」ではなく「判断の背景」を記述する。**
    *   「禁止事項」や「守るべきルール」といった思考停止を招く言葉を避け、「我々はこういう判断をした」といった形で、判断に至った文脈や背景そのものを記述します。
    *   例: 「現時点では、コアロジックとUI의結合を避けるため、両者はSnapshotオブジェクトを通してのみ通信する、という判断をした。」

### 3. リスクと対策 (Risks and Mitigations)

*   **リスク:** ドキュメントが陳腐化し、現実のコードと乖離する。
    *   **対策:** アーキテクチャに影響を与えるコード変更（例: 新コンポーネントの追加、既存APIの責務変更）は、必ずこのマニフェストの更新とセットでレビューします。これは、`DESIGN_PHILOSOPHY.md`で定義された、AIと人間の双方が遵守すべき厳格なプロトコルです。

*   **リスク:** 全体原則と、特定のCPUアーキテクチャ（局所的な要求）が衝突する。
    *   **対策:** 原則としてこの憲章を優先します。ただし、局所的なコード内コメントで明確な理由（例: 「6809の特殊なアドレッシングモードのため、標準バスアクセスを逸脱」）が示されている場合に限り、戦術的な逸脱を許容します。

---
## Part 2: マニフェスト本体 (Content)

### 1. 核となる原則 (Core Principles)

*このセクションは、プロジェクトの不変的なルールを「なぜ」の理由付けと共に定義します。*

- **原則: 教育のための透明性を、実行速度よりも優先する。**
  - **理由:** 本プロジェクトの第一目的は、CPUの内部動作を初心者が直感的に理解できるようにすることである。実行パフォーマンスの最適化は二次的な目標とする。

- **原則: コアロジックは、特定のUI技術から完全に分離される。**
  - **理由:** 将来的にUIをWeb、デスクトップ、CLIなど複数のプラットフォームで再実装する可能性を考慮し、移植性を最大化するため。両者の通信は、後述する不変データ構造「Snapshot」を介してのみ行われる。

- **原則: 複数のCPUアーキテクチャを、単一の抽象モデルで表現する。**
  - **理由:** Z80や6800など、異なるCPUごとのコード重複を最小限に抑え、バスやデバッガなどの共通コンポーネントの再利用性を高めるため。

### 2. 主要なアーキテクチャ決定の記録 (Key Architectural Decisions)

*このセクションは、「なぜこの構造になったのか」を後から追えるように、重要な設計判断をログとして残します。*

- **Date:** 2026-02-05
- **Core Principle:** コアロジックは、特定のUI技術から完全に分離される。
- **Decision:** コアエンジンとUIの間の唯一の接点として、不変（Immutable）なデータ構造「Snapshot」を定義し、採用する。
- **Rationale:** UIはSnapshotを受け取って表示することにのみ責務を持ち、コアエンジンの状態を直接変更するAPIを持たない。これにより、データフローが単一方向となり、状態管理の複雑さが劇的に低下する。また、Snapshotのシーケンスを記録・再生することで、デバッグやテストが容易になる。
- **Alternatives:**
  - Observerパターン: UIがコアエンジンの状態変化を直接購読する。→ 密結合になり、UIの変更がコアに影響を与えるリスクがある。
  - コアエンジンがUIコンポーネントを直接駆動する。→ コアがUIの存在を知ってしまい、移植性を損なう。
- **Consequences:** 1命令ごとにSnapshotオブジェクトを生成するオーバーヘッドが発生するが、原則「教育のための透明性」を優先し、許容する。

- **Date:** 2026-02-11
- **Decision:** 「動的・静的の統合可視化」戦略の採用。
- **Rationale:** 開発の過程で、単なるアニメーションだけでなく、現在のハードウェア構成（メモリマップ、I/O配置）そのものを動的に描画する必要性が高まった。これに対し、UI層が設定データを直接解釈してシーンを構築するアプローチを採用。

- **Date:** 2026-02-12
- **Decision:** ROMデバイスの明示的実装と、アセンブラロジックの分離。
- **Rationale:** 堅牢性を高めるため、ROM領域への書き込みを無視するROMデバイスを導入。また、Loaderクラスの肥大化を防ぐため、アーキテクチャ固有のアセンブリ解析ロジックをAssemblerクラスへ分離した。

### 3. AIとの協調に関する指針 (AI Collaboration Policy)

*このセクションは、AIがどう振る舞うべきかの指針を記述します。*

- **未知の問題への対処:** この憲章に記載のない問題に直面した際、AIは`DESIGN_PHILOSOPHY.md`の根本思想に立ち返り、複数の選択肢とそれぞれのトレードオフを提示し、人間の判断を仰いでください。
- **戦略（憲章）と戦術（コメント）の連携:** この憲章（戦略）と、コード内に記述されるインテント・コメント（戦術）は、一貫性を保つべきです。AIは、コード生成時にインテント・コメントの草案を提案する責務を負います。

### 4. コンポーネント設計仕様 (Component Design Specifications)

*このセクションは、システムの主要コンポーネントの「設計仕様」を定義します。AIと人間は、ここでの合意形成を通じて実装を進めます。詳細な仕様は、各サブディレクトリの`ARCHITECTURE_MANIFEST.md`を参照してください。*

#### 4.1. Transport Layer (共通バス / RAM / ROM)
- **責務 (Responsibility):** メモリアドレス空間を抽象化し、読み書きアクセスを管理する責務。ROMデバイスによる読み込み専用制御を含む。
- **詳細仕様:** `src/retro_core_tracer/transport/ARCHITECTURE_MANIFEST.md` を参照してください。

#### 4.2. Core Layer (抽象CPU)
- **責務 (Responsibility):** 抽象的なCPUの状態管理と、命令サイクルの実行制御に関する責務。
- **詳細仕様:** `src/retro_core_tracer/core/ARCHITECTURE_MANIFEST.md` を参照してください。

#### 4.3. Architecture Layer (Z80 / MC6800)
- **責務 (Responsibility):** 各プロセッサ固有の命令セット、レジスタ構造、状態遷移の定義に関する責務。
- **詳細仕様:** 
    - `src/retro_core_tracer/arch/z80/ARCHITECTURE_MANIFEST.md`
    - `src/retro_core_tracer/arch/mc6800/ARCHITECTURE_MANIFEST.md` を参照してください。

#### 4.4. Hybrid Debugger (デバッガ)
- **責務 (Responsibility):** 実行制御（ステップ実行、ブレークポイント）と、コアの状態観測に関する責務。
- **詳細仕様:** `src/retro_core_tracer/debugger/ARCHITECTURE_MANIFEST.md` を参照してください。

#### 4.5. Code Loader (コードローダー / アセンブラ)
- **責務 (Responsibility):** 実行可能ファイル（HEX/S-Record）の解析、およびアーキテクチャ固有のアセンブリソース解析によるロード責務。Factoryパターンによるローダー生成。
- **詳細仕様:** `src/retro_core_tracer/loader/ARCHITECTURE_MANIFEST.md` を参照してください。

#### 4.6. User Interface (UI)
- **責務 (Responsibility):** コアから受け取った`Snapshot`情報を可視化し、ユーザーとのインタラクションを提供する責務。
- **詳細仕様:** `src/retro_core_tracer/ui/ARCHITECTURE_MANIFEST.md` を参照してください。